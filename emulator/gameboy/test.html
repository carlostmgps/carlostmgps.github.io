
#display2{
  width:650px; height:320px; display:block;
  outline:3px solid #ccc; margin:5px auto;

  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
* {
    touch-action: manipulation;
}

#io2,#stack2{float:left;height:400px;overflow-y:scroll}
#out2{float:left;margin-right:10px}
#dbg2{display:none}</style>
    <div class="gameboy">
    <div class="front-plate">
      <div class="front-plate-head">
        <div class="vertical-stripe"></div>
        <div class="vertical-stripe"></div>
        <div class="vertical-stripe"></div>
  
        <div class="vertical-gouge vertical-gouge-1"></div>
        <div class="vertical-gouge vertical-gouge-2"></div>
  
        <div class="on-off">
          <div class="spike spike-left"><div></div></div>
          <div class="spike spike-right"><div></div></div>
        </div>
      </div>
  
      <div class="screen-container">
        <div class="screen-headline">
          <span>DOT MATRIX WITH STEREO SOUND</span>
        </div>
  
        <div class="battery-light">
          <span>BATTERY</span>
        </div>
  
        <div class="screen">
	  <canvas id=display2 onclick="runto2(0x10000);" ondblclick="fullScreen(this)">
          </canvas>
        </div>
      </div>
  
      <div class="logo"></div>
  
      <div id="controller">
  
        <div class="buttons-a-b">
          <div onmousedown="btdown2(1);" ondblclick="pd(event)" onmouseup="btup2(1);" ontouchstart="btdown2(1);" ontouchend="btup2(1);" class="button-b button-key-j" id="controller_b"></div>
  
          <div onmousedown="btdown2(0);" onmouseup="btup2(0);" ondblclick="pd(event)" ontouchstart="btdown2(0);" ontouchend="btup2(0);" class="button-a button-key-k" id="controller_a"></div> 
        </div>
        
        <div onmousedown="btdown2(3);" onmouseup="btup2(3);" ondblclick="pd(event)" ontouchstart="btdown2(3);" ontouchend="btup2(3);" class="start button-key-m" id="controller_start"><div></div></div>
  
        <div onmousedown="btdown2(2);" onmouseup="btup2(2);" ondblclick="pd(event)" ontouchstart="btdown2(2);" ontouchend="btup2(2);" class="select button-key-n" id="controller_select"><div></div></div>
  
        <div class="cross-container">
          <div class="spike"><div></div></div>
          <div class="spike"><div></div></div>
          <div class="spike"><div></div></div>
          <div class="spike"><div></div></div>
  
          <div class="cross" id="controller_dpad">
            <div class="top-down">
              <div onmousedown="dpaddown2(2);" ondblclick="pd(event)" onmouseup="dpadup2(2);" ontouchstart="dpaddown2(2);" ontouchend="dpadup2(2);" class="button-top button-key-w" id="controller_up">
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
              </div>
              <div onmousedown="dpaddown2(3);" ondblclick="pd(event)" onmouseup="dpadup2(3);" ontouchstart="dpaddown2(3);" ontouchend="dpadup2(3);" class="button-bottom button-key-s" id="controller_down">
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
              </div>
            </div>
  
            <div class="left-right">
              <div onmousedown="dpaddown2(1);" ondblclick="pd(event)" onmouseup="dpadup2(1);" ontouchstart="dpaddown2(1);" ontouchend="dpadup2(1);" class="button-left button-key-a" id="controller_left">
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
              </div>
              <div onmousedown="dpaddown2(0);" ondblclick="pd(event)" onmouseup="dpadup2(0);" ontouchstart="dpaddown2(0);" ontouchend="dpadup2(0);" class="button-right button-key-d" id="controller_right">
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
                <div class="button-stripe"></div>
              </div>
            </div>
            <div class="cross-middle-bumb"></div>
          </div>
        </div>
  
      </div>
  
      <div class="speaker">
        <div><div class="speaker-inner-shadow"></div></div>
        <div><div class="speaker-inner-shadow"></div></div>
        <div><div class="speaker-inner-shadow"></div></div>
        <div><div class="speaker-inner-shadow"></div></div>
        <div><div class="speaker-inner-shadow"></div></div>
        <div><div class="speaker-inner-shadow"></div></div>
      </div>
  
      <div class="phones" id="volume-switch">
        <div class="vertical-stripe"></div>
        <div class="vertical-stripe"></div>
        <div class="vertical-stripe"></div> 
        <i></i>
        <span>PHONES</span>
      </div>
  
    </div>
  
    <div class="power-button" onclick='requestStop2? runto2(0x10000) : requestStop2=true'><div></div></div>
  </div>
  <div id=dbg2>
    <pre id=out2></pre>
    <pre id=io2></pre>
    <pre id=stack2></pre>

    <button onclick="cpu2(); debugData2(); return false">CPU Step2</button>
    <button onclick="requestStop2 ? run2() : (requestStop2=true); return false">Stop / Frame2</button>
    <button onclick="runto2();return false">Run To2...</button>
  </div>


  <div style='width:480px;margin:auto'>
    <input type='file' accept='.gb,.gbc' id=fileinput2 onchange='openFile2(event)'>
    <button onclick="useOnlineRom2()">线上游戏2</button>
    <button onclick='requestStop2? runto2(0x10000) : requestStop2=true' id=start2>开始/暂停2</button>
    <div style='display:inline-block;vertical-align:middle'>
      <label style="display:block"><input type=checkbox checked=checked onchange="limitFrameRate2=this.checked" autocomplete2=off>稳定FPS2</label>
      <label style="display:block"><input type=checkbox onchange="showFrameRate2=this.checked" autocomplete2=off>显示FPS2</label>
    </div>


    <br><br>


    <a href='#' onclick='saveSram2(this);'>下载本机存档2</a> <button onclick="onlineSaveSram2();">上载网上存档2</button> / 
    <a href='#' onclick='document.getElementById("loadsav2").click(); return false;'>上载本机存档</a> <button onclick="onlineLoadSram2();">下载网上存档</button>
    <input type='file' id=loadsav2 style='display:none' accept='.sav' onchange='loadSram2(event)'>
    <button onclick="saveState2(); return false">时空储存2</button>
    <button onclick="loadState2(); return false">时空倒流2</button>
    <button onclick="showDebug2(!debugOn2); return false">Debug2</button>
  </div>

  <br><br>


  <br><br>
<script defer>
var font2=new Image();
font2.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAICAYAAAAGP/oPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAALRJREFUeNrsVtsOgCAIleZ/V19u88HNUdwCrQfZelA8x4gDBCmlIy37zHIUUSll79cAcFJnOB+F1/BTd2Cslf8JL53R8kNEBeCgpY9AvRyF1/Bzd3CJ1/it8VrWeVap1cs0StIqTVKYVKVSFVqS1WLT4LFtf+mFLQBJjVhFGgXX/f7h2hLnl5JP4fs9zJs9pRg9P7wtAidldhzWKr7NAE8CPEM4YsiNHMIjfyJChvCy93YJMAD0L/qXa2HkvgAAAABJRU5ErkJggg==";


var dpixels2 = new Uint8Array(160*144);

var limitFrameRate2 = true;
var showFrameRate2 = false;

var dctx2 = document.getElementById('display2').getContext('2d');

var dImgData2 = dctx2.getImageData(0,0,160,144);

for (i=0;i<160*144;i++){
  dImgData2.data[4*i+3] = 255
}

dctx2.putImageData(dImgData2,0,0)


var lastSampleTime2 = 0;
var frame2 = 0;
var frameRate2 = 0;
const sampleFrames2 = 5;

function renderDisplayCanvas2() {
  //  0  White
  //  1  Light gray
  //  2  Dark gray
  //  3  Black

  var R = [224,136,52, 8 ],
      G = [248,192,104,24],
      B = [208,112,86, 32];

  for (var i=0,j=0;i<160*144;i++){
    dImgData2.data[j++ ] = R[dpixels2[i]]
    dImgData2.data[j++ ] = G[dpixels2[i]]
    dImgData2.data[j   ] = B[dpixels2[i]]
    j+=2
  }
  dctx2.putImageData(dImgData2,0,0)

  if (++frame2 >= sampleFrames2){
    frame2 = 0;
    frameRate2 = ((1000 * sampleFrames2 / (thisFrame2 - lastSampleTime2)) + frameRate2)/2;
    lastSampleTime2 = thisFrame2;
  }

  if(showFrameRate2) {
    var t=frameRate2.toFixed(2);
    for (var c in t) {
      dctx2.drawImage(font2, (t[c].charCodeAt(0)-46)*8, 0, 8,8,c*8,0,8,8)
    }
    
  }
}




// We have infinite RAM
const pixelDecoder2=[]
for (var d1 = 0; d1<256; d1++) {
  pixelDecoder2[d1]=[]
  for (var d2 = 0; d2<256; d2++)
    pixelDecoder2[d1][d2] = [
      ((d1&128)+ 2*(d2&128)) >>7,
      ((d1&64) + 2*(d2&64)) >>6,
      ((d1&32) + 2*(d2&32)) >>5,
      ((d1&16) + 2*(d2&16)) >>4,
      ((d1&8)  + 2*(d2&8)) >>3,
      ((d1&4)  + 2*(d2&4)) >>2,
      ((d1&2)  + 2*(d2&2)) >>1,
      ((d1&1)  + 2*(d2&1))
    ]
}


// LFSR prescaler lookups
const snd4bit42 = [ // 3-bit "shift clock frequency"
  2,
  4,
  8,
  16,
  32,
  64,
  128,
  256,
  512,
  1024,
  2048,
  4096,
  8192,
  16384,
  16384,// Prohibited code
  16384 // Prohibited code
]
const snd4bit32 = [ // 4 bit "prescaler input clock" (14 step)
  4 /4194304,
  8 /4194304,
  16/4194304,
  24/4194304,
  32/4194304,
  40/4194304,
  48/4194304,
  56/4194304
]

var SoundEnabled2 = false;
var audioCtx2 = new (window.AudioContext || window.webkitAudioContext)();

const FFTsize2 = 512
var reverseTable2 = new Uint32Array(FFTsize2);
var lfsr7bit2 = new Float32Array(127), lfsr15bit2=new Float32Array(32767);
(function(){
  var limit = 1,  bit = FFTsize2 >> 1;
  
  // reverse table for FFT
  while ( limit < FFTsize2 ) {
    for ( i = 0; i < limit; i++ ) {
      reverseTable2[i + limit] = reverseTable2[i] + bit;
    }
    limit = limit << 1;
    bit = bit >> 1;
  }

  // precalculate LFSR patterns
  var start_state2 = 127;
  var lfsr2 = start_state2;
  var st2=0

  do {
    bit  = ((lfsr2 >> 0) ^ (lfsr2 >> 1) ) & 1;
    lfsr2 =  (lfsr2 >> 1) | (bit << 6);
    lfsr7bit2[st++]=(bit/4-0.125);
  } while (lfsr2 != start_state2); // has a period of 127

  st2=0;
  do {
    bit  = ((lfsr2 >> 0) ^ (lfsr2 >> 1)) & 1;
    lfsr2 =  (lfsr2 >> 1) | (bit << 14);
    lfsr15bit2[st++]=(bit/4-0.125);
  } while (lfsr2 != start_state2); // period of 32767

})();



	
function setSound3Waveform2() {
  if (!sound2[3].waveChanged) return;
  var i, real = new Float32Array(FFTsize2), imag = new Float32Array(FFTsize2), samples=new Float32Array(FFTsize2);

  // sufficiently square edges!
  for ( i = 0; i < 16; i++ ) {
     samples2[32*i+0] = 
     samples2[32*i+1] = 
     samples2[32*i+2] = 
     samples2[32*i+3] = 
     samples2[32*i+4] = 
     samples2[32*i+5] = 
     samples2[32*i+6] = 
     samples2[32*i+7] = 
     samples2[32*i+8] = 
     samples2[32*i+9] = 
     samples2[32*i+10] = 
     samples2[32*i+11] = 
     samples2[32*i+12] = 
     samples2[32*i+13] = 
     samples2[32*i+14] = 
     samples2[32*i+15] = 
      MEM2[0xFF30 + i]>>4;
     samples2[32*i+16] = 
     samples2[32*i+17] = 
     samples2[32*i+18] = 
     samples2[32*i+19] = 
     samples2[32*i+20] = 
     samples2[32*i+21] = 
     samples2[32*i+22] = 
     samples2[32*i+23] = 
     samples2[32*i+24] = 
     samples2[32*i+25] = 
     samples2[32*i+26] = 
     samples2[32*i+27] = 
     samples2[32*i+28] = 
     samples2[32*i+29] = 
     samples2[32*i+30] = 
     samples2[32*i+31] = 
      MEM2[0xFF30 + i]&0x0F;
  }

  
  for ( i = 0; i < FFTsize2; i++ ) {
    real[i] = samples2[reverseTable2[i]]/4096;
    imag[i] = 0;
  }
  
  var halfSize = 1,
    phaseShiftStepReal,
    phaseShiftStepImag,
    currentPhaseShiftReal,
    currentPhaseShiftImag,
    off,
    tr,
    ti,
    tmpReal;

  while ( halfSize < FFTsize2 ) {
    phaseShiftStepReal = Math.cos(-3.141592653589793/halfSize);
    phaseShiftStepImag = Math.sin(-3.141592653589793/halfSize);
    currentPhaseShiftReal = 1.0;
    currentPhaseShiftImag = 0.0;

    for ( var fftStep = 0; fftStep < halfSize; fftStep++ ) {
      i = fftStep;

      while ( i < FFTsize ) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }
    halfSize = halfSize << 1;
  }
  sound2[3].oscillator.setPeriodicWave(
    audioCtx2.createPeriodicWave(real.slice(0,FFTsize2/2),imag.slice(0,FFTsize2/2), {disableNormalization:true})
  );
  sound2[3].waveChanged=false;
};


const sound2 = {
  1:{ // Square / Pulse with sweep and envelope
    oscillator:audioCtx2.createOscillator(),
    freq: function(f) { sound2[1].oscillator.frequency.setValueAtTime(f, audioCtx2.currentTime) },
    duty: function(d) { sound2[1].oscillator.setPeriodicWave( sound2.pulses[d] ) },
    sweepTime: 0,
    sweepDir: 1,
    sweepShift: 0,
    sweepPrescaler: 0,
    freqnum: 0
  },
  2:{ // Square / Pulse with envelope
    oscillator:audioCtx2.createOscillator(),
    freq: function(f) { sound2[2].oscillator.frequency.setValueAtTime(f, audioCtx2.currentTime) },
    duty: function(d) { sound2[2].oscillator.setPeriodicWave( sound2.pulses[d] ) }
  },
  3:{ // Wave playback
    oscillator:audioCtx2.createOscillator(),
    freq: function(f) { sound2[3].oscillator.frequency.setValueAtTime(f, audioCtx2.currentTime) },
    waveChanged:true
  },
  4:{ //Noise
    oscillator:audioCtx2.createScriptProcessor(2048, 1, 1),
    polySteps:function(x){ lfsrPhase2=0;sound2[4].oscillator.onaudioprocess = x?processLFSR7bit2:processLFSR15bit2; },
    bitPeriod:1,
    freq:function(bits4, bits3){ 
      sound2[4].bitPeriod=(audioCtx2.sampleRate * snd4bit42[bits4] * snd4bit32[bits3])
    }
  }
}

function generatePulseWave(duty){
  var res = 256; // up to 8192 according to spec
  var real = new Float32Array(res);
  var imag = new Float32Array(res);

  real[0] = 0.5*duty;
  for (var n = 1; n<res; n++) {
    real[n] = 0.5*Math.sin( 3.141592653589793*n*duty )/(1.570796326794896*n)
  }
  return audioCtx2.createPeriodicWave(real,imag, {disableNormalization:true});
}

sound2.pulses = [
  generatePulseWave(0.125),
  generatePulseWave(0.25),
  generatePulseWave(0.5),
  generatePulseWave(0.75)
]

var lfsrPhase2=0;
var processLFSR7bit2=function(e){
  var output = e.outputBuffer.getChannelData(0);
  var j=1/sound[4].bitPeriod;

  for (var i = 0; i < 2048; i++) {
    lfsrPhase2+=j
    if (lfsrPhase2>127) lfsrPhase2=0;
    
    output[i] = lfsr7bit2[ ~~lfsrPhase2 ]
  }

}
var processLFSR15bit2=function(e){
  var output = e.outputBuffer.getChannelData(0);
  var j=Math.ceil(sound2[4].bitPeriod);
  
  for (var i = 0; i < 2048; i+=j) {
    if ((++lfsrPhase2)>=32767) lfsrPhase2-=32767;
    var s = lfsr15bit2[ lfsrPhase2 ]
    for (var p=j;p--;) output[i+p] = s;
  }
}



sound2.SO1 = audioCtx.createGain()
sound2.SO2 = audioCtx.createGain()

for (var i=1;i<=4;i++){
  sound2[i].gainNode=audioCtx2.createGain()
  sound2[i].amp=function(a) { this.gainNode.gain.setValueAtTime(a, audioCtx2.currentTime) }
  sound2[i].amp(0)
  sound2[i].oscillator.connect(sound2[i].gainNode)
  sound2[i].gainNode.connect(sound2.SO1)
  sound2[i].gainNode.connect(sound2.SO2)

  sound2[i].initialized = false;
  sound2[i].lengthEnabled = false;
  sound2[i].length = 0;
  sound2[i].env = 0;
  sound2[i].envSpeed = 0;
  sound2[i].envDirection = 0;
  sound2[i].envCounter = 0;
}

sound2[1].oscillator.start()
sound2[2].oscillator.start()
sound2[3].oscillator.start()
sound2[4].oscillator.onaudioprocess = processLFSR15bit2;

sound2.final = audioCtx2.createChannelMerger(2)
sound2.SO1.connect(sound.final, 0, 1)
sound2.SO2.connect(sound.final, 0, 0)

sound2.final.connect(audioCtx2.destination)

audioCtx2.suspend()


/*
Memory map

	$FFFF       	Interrupt Enable Flag
	$FF80-$FFFE 	HRAM - 127 bytes
	$FF00-$FF7F 	Hardware I/O Registers
	$FEA0-$FEFF 	Unusable Memory
	$FE00-$FE9F 	OAM - Object Attribute Memory
	$E000-$FDFF 	Echo RAM - Reserved, Do Not Use
	$D000-$DFFF 	Internal RAM - Bank 1-7 (switchable - CGB only)
	$C000-$CFFF 	Internal RAM - Bank 0 (fixed)
	$A000-$BFFF 	Cartridge RAM (If Available)
	$9C00-$9FFF 	BG Map Data 2
	$9800-$9BFF 	BG Map Data 1
	$8000-$97FF 	Character RAM
	$4000-$7FFF 	Cartridge ROM - Switchable Banks 1-xx
	$0150-$3FFF 	Cartridge ROM - Bank 0 (fixed)
	$0100-$014F 	Cartridge Header Area
	$0000-$00FF 	Restart and Interrupt Vectors

Bank switch:  write bank number to $2000 

  Cartridge RAM has separate bank number to cartridge ROM


Bootcode: 
  load first bank of rom into MEM
  overwrite first 256 bytes with bootcode
  after verification, overwrite first 256 bytes with data from rom

*/










var MEM2 = new Uint8Array(0x10000); // Main address space
var FirstROMPage2, ROM2 = new Uint8Array(512); //populate later
var ROMbank2 = 1; 
var ROMbankoffset2 = (ROMbank2-1)*0x4000;

var cartRAM2 = new Uint8Array(0x8000); // some carts have up to 128K of ram?
var RAMbank2 =0; 
var RAMbankoffset2 = RAMbank2*0x2000 - 0xA000;
var RAMenabled2=false;
var MBCRamMode2=0; //for MBC1

var divPrescaler2=0, timerPrescaler2=0, timerLength2=1, timerEnable2=false;
var LCD_enabled2 = false, LCD_lastmode2=1, LCD_scan2=0;
var joypad_dpad2 = 0xef, joypad_buttons2=0xdf; // 0=pressed
var keys_dpad2 = 0xef, keys_buttons2=0xdf; // 0=pressed

var dpaddown2 = function(n){keys_dpad2 &=~(1<<n);}
var dpadup2 = function(n){keys_dpad2 |=(1<<n);}
var btdown2 = function(n){keys_buttons2 &=~(1<<n);}
var btup2 = function(n){keys_buttons2 |=(1<<n);}




function readMem2(addr){
  if (addr <= 0x3fff) return ROM2[ addr ];
  if (addr <= 0x7fff) return ROM2[ addr + ROMbankoffset2 ];

  // Cartridge RAM
  if (addr >= 0xA000 && addr <=0xBFFF) return cartRAM2[ addr + RAMbankoffset2 ];

  // Joypad
  if (addr==0xFF00) {
    if (MEM2[0xFF00]&0x20) {
      return joypad_dpad2 & keys_dpad2
    } else if (MEM2[0xFF00]&0x10) {
      return joypad_buttons2 & keys_buttons2
    } else return 0xFF;
  }

  return MEM2[addr];
}

function readMem162(addr){
  //just presuming that some peripherals will need to hook on 16 bits
  return [readMem2(addr+1),readMem2(addr)]
}

function writeMem2(addr, data){
  if (addr<=0x7fff) { 
    doMBC2(addr, data);
    return;
  }

  if (addr >= 0xA000 && addr <=0xBFFF && RAMenabled2){
    cartRAM2[ addr + RAMbankoffset2 ] = data;
    return
  }

  //DIV register: reset
  if (addr==0xFF04) {MEM2[0xFF04]=0;return;}
  // Timer control
  if (addr==0xFF07) {
    timerEnable2 = ((data&(1<<2))!=0);
    timerLength2 = [ 1024, 16, 64, 256 ][ data&0x3 ];
    timerPrescaler2=timerLength2; //+cycles for this instruction?
    MEM2[addr] = 0xF8|data;
    return;
  }

  // Sound Control
  if (addr==0xFF26) {
    if (data&(1<<7)) {
      MEM2[0xFF26]=data&(1<<7);
      SoundEnabled2 = true;
      audioCtx2.resume()
    } else {
      SoundEnabled2 = false;
      // should we set each oscillator to amplitude zero too?
      audioCtx2.suspend()
      // Zero all sound registers
      resetSoundRegisters2();
    }
    return;
  }
  if (addr>=0xFF10 && addr <=0xFF25) {
    if (!SoundEnabled2) return;
    // FF10 - NR10 - Channel 1 Sweep register (R/W)
    if (addr == 0xFF10) {
      sound2[1].sweepTime = (data>>4)&0x7;
      sound2[1].sweepPrescaler = sound2[1].sweepTime;
      sound2[1].sweepDir = (data&(1<<3)) ? 0 : 1;
      sound2[1].sweepShift = data&0x7;
      MEM2[addr] = data &0x80
      return;
    }
    // FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)
    if (addr == 0xFF11) {
      MEM2[addr] = data;
      sound2[1].duty(data>>6)
      return;
    }
    // FF12 - NR12 - Channel 1 Volume Envelope (R/W)
    if (addr == 0xFF12) {
      MEM2[addr] = data
      sound2[1].envDirection = (data&(1<<3)) ? 1: -1;
      sound2[1].envSpeed = data&0x7;
      sound2[1].envCounter = 0;
      return;
    }
    // FF13 - NR13 - Channel 1 Frequency lo (Write Only)
    if (addr == 0xFF13) {
      sound2[1].freqnum=(((MEM2[0xFF14]&0x7)<<8)+ data);
      sound2[1].freq(  131072/(2048-  sound2[1].freqnum  )  )
      MEM2[addr] = data
      return;
    }
    // FF14 - NR14 - Channel 1 Frequency hi (R/W)
    if (addr == 0xFF14) {
      //bit 7 is initialize
      sound2[1].freqnum=(((data&0x7)<<8)+ MEM2[0xFF13]);
      sound2[1].freq(  131072/(2048-  sound2[1].freqnum  )  )
      if (data&(1<<7)) {
        sound2[1].initialized = true
        sound2[1].env = MEM2[0xFF12]>>4; // default envelope value
        sound2[1].envCounter = 0;
        sound2[1].amp( sound2[1].env/15 )

        sound2[1].lengthEnabled = (data&(1<<6)) !=0;
        sound2[1].length = (64-(MEM2[0xFF11]&0x3F));

        MEM2[0xFF26] |= (1<<0) // flag sound 1 as on
      }
      MEM2[addr] = data
      return;
    }


    // FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)
        // Bit 7-6 - Wave Pattern Duty (Read/Write)
        // Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
    if (addr == 0xFF16) {
      MEM2[addr] = data
      sound2[2].duty(data>>6)
      return;
    }

    // FF17 - NR22 - Channel 2 Volume Envelope (R/W)
    if (addr == 0xFF17) {
      MEM2[addr] = data
      sound2[2].envDirection = (data&(1<<3)) ? 1: -1;
      sound2[2].envSpeed = data&0x7;
      sound2[2].envCounter = 0;
      return;
    }
    // FF18 - NR23 - Channel 2 Frequency lo data (W)
    if (addr == 0xFF18) {
      sound2[2].freq(  131072/(2048-  (((MEM2[0xFF19]&0x7)<<8)+ data)  )  )
      MEM2[addr] = data
      return;
    }
    // FF19 - NR24 - Channel 2 Frequency hi data (R/W)
    if (addr == 0xFF19) {
      sound2[2].freq(  131072/(2048-  (((data&0x7)<<8)+ MEM2[0xFF18])  )  )
      //bit 7 is initialize
      if (data&(1<<7)) {
        sound2[2].initialized = true
        sound2[2].env = MEM2[0xFF17]>>4; //Default envelope value
        sound2[2].envCounter = 0;
        sound2[2].amp( sound2[2].env/15 )

        sound2[2].lengthEnabled = (data&(1<<6)) !=0;
        sound2[2].length = (64-(MEM2[0xFF16]&0x3F));
        MEM2[0xFF26] |= (1<<1) // flag sound 2 as on
      }
      MEM2[addr] = data
      return;
    }

    // Sound 3 - user-defined waveform
    // "it can output a sound while changing its length, frequency, and level"
    // not sure what changing its length means

    // FF1A - NR30 - Channel 3 Sound on/off (R/W)
    if (addr==0xFF1A) {
      if (data&(1<<7)) {
        sound2[3].initialized=true;

        // is this the right (only?) place to load the waveform?
        setSound3Waveform2()

      } else {
        sound2[3].initialized=false;
        sound2[3].amp(0)
      }
      return;
    }
    // FF1B - NR31 - Channel 3 Sound Length
    if (addr==0xFF1B) {
      MEM2[addr] = data
      return;
    }
    // FF1C - NR32 - Channel 3 Select output level (R/W)
    if (addr==0xFF1C) {
      // Really we ought to bit-crush it, but whatever
      if (sound2[3].initialized) sound2[3].amp( [ 0,0.5,0.25,0.125 ][((data>>5)&0x3)] )
      MEM2[addr] = data
      return;
    }

    // FF1D - NR33 - Channel 3 Frequency's lower data (W)
    if (addr == 0xFF1D) {
      sound2[3].freq(   65536/(2048-  (((MEM2[0xFF1E]&0x7)<<8)+ data)  )  )
      MEM2[addr] = data
      return;
    }
    // FF1E - NR34 - Channel 3 Frequency's higher data (R/W)
    if (addr2 == 0xFF1E) {
      sound2[3].freq(   65536/(2048-  (((data&0x7)<<8)+ MEM2[0xFF1D])  )  )
      //bit 7 is initialize
      if (data&(1<<7)) {

        sound2[3].initialized = true

        sound2[3].amp( [ 0,0.5,0.25,0.15 ][((MEM2[0xFF1C]>>5)&0x3)] )

        sound2[3].lengthEnabled = (data&(1<<6)) !=0;
        sound2[3].length = (256-MEM2[0xFF1B]);

        MEM2[0xFF26] |= (1<<2) // flag sound 3 as on
      }
      MEM2[addr] = data
      return;
    }

    // Sound 4 - Noise
    // FF20 - NR41 - Channel 4 Sound Length (R/W)
    if (addr==0xFF20) {
      MEM2[addr] = data
      return;
    }
    // FF21 - NR42 - Channel 4 Volume Envelope (R/W)
    if (addr==0xFF21) {
      MEM2[addr] = data
      sound2[4].envDirection = (data&(1<<3)) ? 1: -1;
      sound2[4].envSpeed = data&0x7;
      sound2[4].envCounter = 0;
      return;
    }
    // FF22 - NR43 - Channel 4 Polynomial Counter (R/W)
    if (addr==0xFF22) {
      sound2[4].freq(data>>4, data&0x7)
      sound2[4].polySteps(data&(1<<3))

      MEM2[addr] = data
      return;
    }
    // FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)
    if (addr==0xFF23) {

      sound2[4].initialized = true
      sound2[4].env = MEM2[0xFF21]>>4; //Default envelope value
      sound2[4].envCounter = 0;
      sound2[4].amp( sound[4].env/15 )
      sound2[4].length = (64-(MEM2[0xFF20]&0x3F));
      
      MEM2[0xFF26] |= (1<<3) // flag sound 4 as on

      sound2[4].lengthEnabled = (data&(1<<6)) !=0;
      MEM2[addr] = data; 
      return
    }


    // FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)
    if (addr == 0xFF24) {
       //  Bit 7   - Output Vin to SO2 terminal (1=Enable)
       //  Bit 6-4 - SO2 output level (volume)  (0-7)
       //  Bit 3   - Output Vin to SO1 terminal (1=Enable)
       //  Bit 2-0 - SO1 output level (volume)  (0-7)

      // is level zero mute ? "minimum level"
      sound2.SO2.gain.setValueAtTime(((data>>4)&0x7)/7, audioCtx2.currentTime)
      sound2.SO1.gain.setValueAtTime((data&0x7)/7,      audioCtx2.currentTime)
      MEM2[addr] = data; 
      return
    }

    // FF25 - NR51 - Selection of Sound output terminal (R/W)
    if (addr == 0xff25) {

      var con = (MEM2[0xff25]^data) & data;
      var dis = (MEM2[0xff25]^data) & (~data);

      for (var i=0;i<4;i++) {
        if (con&(1<<i)){
	  try {
            sound2[i+1].gainNode.connect(sound2.SO1)
          }catch (error) {
            console.log(error);
          }
	}
        if (dis&(1<<i)){
	  try {
            sound2[i+1].gainNode.disconnect(sound2.SO1)
          }catch (error) {
            console.log(error);
          }
        }
        if (con&(1<<(4+i))){
	  try {
            sound2[i+1].gainNode.connect(sound2.SO2)
          }catch (error) {
            console.log(error);
          }
	}
        if (dis&(1<<(4+i))){
	  try {
            sound2[i+1].gainNode.disconnect(sound2.SO2)
          }catch (error) {
            console.log(error);
          }
        }
      }
      MEM2[addr] = data; 
      return
    }

    return;
  }
  if (addr>=0xFF30 && addr<=0xFF3F) sound2[3].waveChanged=true;

  //LCD control
  if (addr==0xFF40) {
    var cc = data&(1<<7);
    if (LCD_enabled2 !=cc) {
      LCD_enabled2=!!cc;
      if (!LCD_enabled2){ // Disabling the display sets it to mode 1
        // this should also probably set all pixels to white
        LCD_scan2=0;
        MEM2[0xFF41] = (MEM2[0xFF41] & 0xFC) +1;
      }
    }
  }
  if (addr==0xFF41) {
    //don't overwrite the lowest two bits (mode)
    MEM2[0xFF41] &= 0x3
    data &= 0xFC
    MEM2[0xFF41] |= 0x80|data; // BGB has highest bit always set
    return;
  }

  // LY - write causes reset
  if (addr==0xFF44) { MEM2[0xFF44] = 0; return }

  // FF46 - DMA - DMA Transfer and Start Address (W)
  if (addr==0xFF46) {
    var st=data<<8;
    for (var i=0;i<=0x9F;i++) 
      MEM2[0xFE00 +i] = readMem2(st + i);
    return
  }

  // disable bootrom
  if (addr==0xFF50) { for (var i=0;i<256;i++) ROM2[i]=FirstROMPage2[i]; return}

  MEM2[addr] = data;
}
function writeMem162(addr, dataH, dataL){
  writeMem2(addr, dataL)
  writeMem2(addr+1, dataH)
}

function doMBC2(addr, data){

  switch (ROM2[0x147]) {

  // Cartridge Type = ROM[0x147]

  case 0: // ROM ONLY
    // do any type 0 carts have switchable ram?
  break;

  case 0x01: //  MBC1
  case 0x02: //  MBC1+RAM
  case 0x03: //  MBC1+RAM+BATTERY
    if (addr <= 0x1FFF) {
      RAMenabled2 = ((data & 0x0F) == 0xA) 
    } else if (addr <= 0x3FFF){
      data &= 0x1F;
      if (data==0) data=1 // MBC1 translates bank 0 to bank 1 (apparently regardless of upper bits)
      // set lowest 5 bits of bank number
      ROMbank2 = (ROMbank2&0xE0)|(data&0x1F);
      ROMbankoffset2 = (ROMbank2-1)*0x4000 %ROM2.length;
    } else if (addr<=0x5fff) {
      data &= 0x3
      if (MBCRamMode2==0) {
        ROMbank2 = (ROMbank2&0x1F)|(data<<5);
        ROMbankoffset2 = (ROMbank2-1)*0x4000  %ROM2.length;
      } else {
        RAMbank2=data;
        RAMbankoffset2 = RAMbank2*0x2000 - 0xA000
      }
    } else {
      MBCRamMode2 = data&1;
      if (MBCRamMode2==0) {
        RAMbank2=0;
        RAMbankoffset2 = RAMbank2*0x2000 - 0xA000
      } else {
        ROMbank2 &=0x1F;
        ROMbankoffset2 = (ROMbank2-1)*0x4000  %ROM2.length;
      }
    }
    
  break;

  case 0x05: //  MBC2
  case 0x06: //  MBC2+BATTERY
    
    if (addr <= 0x1FFF) {
      if ((addr&0x0100) ==0)
        RAMenabled2 = ((data & 0x0F) == 0xA) 
    } else if (addr <= 0x3FFF){
      data &=0x0F;
      if (data==0) data=1
      ROMbank2 = data;
      ROMbankoffset2 = (ROMbank2-1)*0x4000 %ROM2.length;
    }

  break;

  // case 0x08: //  ROM+RAM
  // case 0x09: //  ROM+RAM+BATTERY
  // case 0x0B: //  MMM01
  // case 0x0C: //  MMM01+RAM
  // case 0x0D: //  MMM01+RAM+BATTERY
  // case 0x0F: //  MBC3+TIMER+BATTERY
  // case 0x10: //  MBC3+TIMER+RAM+BATTERY
  case 0x11: //  MBC3
  case 0x12: //  MBC3+RAM
  case 0x13: //  MBC3+RAM+BATTERY

    if (addr <= 0x1FFF) {
      RAMenabled2 = ((data & 0x0F) == 0xA) 
    } else if (addr <= 0x3FFF){
      if (data==0) data=1 // allows access to banks 0x20, 0x40, 0x60
      ROMbank2 = data&0x7F;
      ROMbankoffset2 = (ROMbank2-1)*0x4000 %ROM2.length;
    } else if (addr<=0x5fff) {
      if (data < 8) {
        RAMbank2=data;
        RAMbankoffset2 = RAMbank2*0x2000 - 0xA000
      } else{
        // RTC registers here
      }
    } else {
      // RTC latch
    }
  break;

  case 0x19: //  MBC5
  case 0x1A: //  MBC5+RAM
  case 0x1B: //  MBC5+RAM+BATTERY
  // case 0x1C: //  MBC5+RUMBLE
  // case 0x1D: //  MBC5+RUMBLE+RAM
  // case 0x1E: //  MBC5+RUMBLE+RAM+BATTERY
    if (addr <= 0x1FFF) {
      RAMenabled2 = ((data & 0x0F) == 0xA) 
    } else if (addr <= 0x2FFF){
      // Allows access to bank 0
      ROMbank2 &= 0x100;
      ROMbank2 |= data;
      ROMbankoffset2 = (ROMbank2-1)*0x4000;
      while (ROMbankoffset2>ROM2.length) ROMbankoffset2-=ROM2.length;
    } else if (addr <= 0x3FFF){
      ROMbank2 &= 0xFF;
      if (data&1) ROMbank2+=0x100;
      ROMbankoffset2 = (ROMbank2-1)*0x4000;
      while (ROMbankoffset2>ROM2.length) ROMbankoffset2-=ROM2.length;
    } else if (addr<=0x5fff) {
      RAMbank2=data&0x0F;
      RAMbankoffset2 = RAMbank2*0x2000 - 0xA000
    }
  break;

  // case 0x20: //  MBC6
  // case 0x22: //  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  // case 0xFC: //  POCKET CAMERA
  // case 0xFD: //  BANDAI TAMA5
  // case 0xFE: //  HuC3
  // case 0xFF: //  HuC1+RAM+BATTERY

    default: throw Error("Unimplemented memory controller");

  }
}
function resetSoundRegisters(){
  
   MEM2[0xFF10] = 0x80   // NR10
   MEM2[0xFF11] = 0xBF   // NR11
   MEM2[0xFF12] = 0xF3   // NR12
   MEM2[0xFF13] = 0
   MEM2[0xFF14] = 0xBF   // NR14
   MEM2[0xFF15] = 0xFF // NA
   MEM2[0xFF16] = 0x3F   // NR21
   MEM2[0xFF17] = 0x00   // NR22
   MEM2[0xFF18] = 0
   MEM2[0xFF19] = 0xBF   // NR24
   MEM2[0xFF1A] = 0x7F   // NR30
   MEM2[0xFF1B] = 0xFF   // NR31
   MEM2[0xFF1C] = 0x9F   // NR32
   MEM2[0xFF1D] = 0
   MEM2[0xFF1E] = 0xBF   // NR33
   MEM2[0xFF1F] = 0xFF // NA
   MEM2[0xFF20] = 0xFF   // NR41
   MEM2[0xFF21] = 0x00   // NR42
   MEM2[0xFF22] = 0x00   // NR43
   MEM2[0xFF23] = 0xBF   // NR30
   MEM2[0xFF24] = 0x77   // NR50
   writeMem2(0xFF25,0xF3)  // NR51
   MEM2[0xFF26] = 0xF1   // NR52

}




var REG2 = new Uint8Array(8);

var FLAGS2 = {
  Z:false,
  N:false,
  H:false,
  C:false
}

var PC2 = 0

var SP2 = 0

var IME2 = false // Interrupt master enable
var cpu_halted2=false;



const opcodes2 = Array(256);
for (var i=0;i<256;i++) opcodes2[i]=function(){ throw Error("Undefined Opcode" )};

const CBcodes2 = Array(256);
for (var i=0;i<256;i++) CBcodes2[i]=function(){ throw Error("Undefined 0xCB Opcode" )};


function ld2(a,b){ 

  if (b==Immediate) return function(){
    REG2[a] = readMem2( PC+1 );
    PC2+=2
    return 8;
  }

  return function(){
    REG2[a] = REG2[b];
    PC2++
    return 4;
  }
}
function ld_from_mem2(a, b, c){
  if (b==Immediate) return function(){
    REG2[a] = readMem2( readMem2( PC2+1 ) + (readMem2( PC2+2 ) <<8) );
    PC2+=3;
    return 16;
  }

  return function(){
    REG2[a] = readMem2( (REG2[b]<<8)+REG2[c] );
    PC2++;
    return 8;
  }
}

function ld_to_mem2(a, b, c){
  if (a==Immediate) return function(){
    writeMem2( readMem2( PC2+1 ) + (readMem2( PC2+2 ) <<8), REG2[b] )
    PC2+=3
    return 16;
  }
  if (c==Immediate) return function(){
    writeMem2( (REG2[a]<<8)+REG2[b] , readMem2(PC2+1) );
    PC2+=2
    return 12
  }
  return function(){
    writeMem2( (REG2[a]<<8)+REG2[b] , REG2[c] );
    PC2++
    return 8
  }
}

// Messy...
function ld162(a,b,c){
  if (b==Immediate) {
    if (a==HL) return function(){
      // mem to hl
      var s = readMem162(readMem2( PC2+1 ) + (readMem2( PC2+2 )<<8));

      REG2[H] = s[0]
      REG2[L] = s[1]

      PC2+=3
      return 12
    }

    // immediate into SP... 
    return function(){
      SP2 = readMem2( PC2+1 ) + (readMem2( PC2+2 ) <<8)
      PC2+=3
      return 12
    }

  }
  if (c==Immediate) return function(){
    
    REG2[a] = readMem2( PC2+2 )
    REG2[b] = readMem2( PC2+1 )

    PC2+=3
    return 12
  }

  // ld sp, hl
  return function(){
    SP2 = (REG2[H]<<8) + REG2[L]
    PC2++
    return 8
  }
}

function ldd2(a,b){ //load with decrement
  if (a==HL) return function(){
    writeMem2( (REG2[H]<<8)+REG2[L] , REG2[A] );

    if (REG2[L]==0) REG2[H]--;
    REG2[L]--;
    
    PC2++
    return 8
  }

  return function(){
    REG2[A] = readMem2( (REG2[H]<<8)+REG2[L] );

    if (REG2[L]==0) REG2[H]--;
    REG2[L]--;

    PC2++
    return 8
  }

}
function ldi2(a,b){ //load with increment
  if (a==HL) return function(){
    writeMem2( (REG2[H]<<8)+REG2[L] , REG2[A] );
    
    if (REG2[L]==255) REG2[H]++;
    REG2[L]++;
    
    PC2++
    return 8
  }

  return function(){
    REG2[A] = readMem2( (REG2[H]<<8)+REG2[L] );

    if (REG2[L]==255) REG2[H]++;
    REG2[L]++;

    PC2++
    return 8
  }

}

function ldc2(a,b){
  if (a==A) return function(){ //LD   A, (FF00+C)
    REG2[A] = readMem2( 0xFF00 + REG2[C] )
    PC2++
    return 8
  }
  return function(){ //LD   (FF00+C),A
    writeMem2(0xFF00 + REG2[C], REG2[A])
    PC2++
    return 8
  }
}
function ldh2(a,b){
  if (a==A) return function(){ //LD   A, (FF00+n)
    REG2[A] = readMem2( 0xFF00 + readMem2(PC2+1) )
    PC2+=2
    return 12
  }
  return function(){ //LD   (FF00+n),A
    writeMem2(0xFF00 + readMem2(PC+1), REG2[A])
    PC2+=2
    return 12
  }
}


function ALU2(op, a, b){

  if (b == Immediate) return function(){
    REG2[A] = ALU_process_8bit2( op, readMem2( PC2+1 ) )
    PC2+=2
    return 8
  }
  if (b == HL) return function(){
    REG2[A] = ALU_process_8bit2( op, readMem2( (REG2[H]<<8)+REG2[L] ) );
    PC2++
    return 8
  }
  return function(){
    REG2[A] = ALU_process_8bit2( op, REG2[b]);
    PC2++
    return 4
  }
}


function ALU_process_8bit2(op, b){

  var result = REG2[A];
  FLAGS2.N = false;

  switch (op){
    case ADD: 
      FLAGS2.H = !!(((REG2[A]&0x0F) + (b&0x0F)) & 0x10)
      result += b;
    break;
    case ADC:
      FLAGS2.H = !!(((REG2[A]&0x0F) + (b&0x0F) + FLAGS2.C) & 0x10)
      result += b + FLAGS2.C;
    break;
    case SUB: 
      result -= b;
      FLAGS2.N = true;
      FLAGS2.H = !!(((REG2[A]&0x0F) - (b&0x0F)) & 0x10)
    break;

    case CP:
      result -= b;
      FLAGS2.N = true;
      FLAGS2.H = !!(((REG2[A]&0x0F) - (b&0x0F)) & 0x10)
      FLAGS2.Z = ((result & 0xff) == 0)
      FLAGS2.C = result > 255 || result < 0;
    return REG2[A];

    case SBC:
      result -= b + FLAGS2.C;
      FLAGS2.N = true;
      FLAGS2.H = !!(((REG2[A]&0x0F) - (b&0x0F) - FLAGS2.C) & 0x10)
    break;
    case AND:
      result &= b;
      FLAGS2.H = true
    break;
    case OR:
      result |= b;
      FLAGS2.H = false
    break;
    case XOR: 
      result ^= b;
      FLAGS2.H = false
    break;

  }

  FLAGS2.Z = ((result&0xff) == 0)
  FLAGS2.C = result > 255 || result < 0;

  return result&0xFF;
}

function inc2(a){return incdec2(a, 1)}
function dec2(a){return incdec2(a, -1)}

function incdec2(r,offset) {
  if (r==HL) return function(){
    writeMem2((REG2[H]<<8)+REG2[L], incdec_process_8bit2( readMem2( (REG2[H]<<8)+REG2[L] ) ,offset))
    PC2++
    return 12
  }

  return function(){
    REG2[r]=incdec_process_8bit2(REG2[r],offset)
    PC2++
    return 4
  }
}

function incdec_process_8bit2(a,offset) {
    var result = a+offset;
    FLAGS2.H = !!(((a&0x0F) +offset) & 0x10)
    FLAGS2.N = offset == -1
    FLAGS2.Z = ((result & 0xff) == 0)
    return result;
}

// 16 bit inc / dec affect no flags
function inc162(a,b) {
  if (a==SPr) return function(){
    SP2++
    PC2++
    return 8
  }
  return function(){
    if (REG2[b] ==255) REG2[a]++;
    REG2[b]++;
    PC2++;
    return 8
  }
}
function dec162(a,b) {
  if (a==SPr) return function(){
    SP2--
    PC2++
    return 8
  }
  return function(){
    if (REG2[b] ==0) REG2[a]--;
    REG2[b]--;
    PC2++;
    return 8
  }
}

function signedOffset2(b){
  return (b>127)? (b-256) : b;
}

function jrNZ2(){
  if (FLAGS2.Z) {PC2+=2; return 8}
  PC2 += 2+signedOffset2(readMem2(PC2+1))
  return 12
}

function jrNC2(){
  if (FLAGS2.C) {PC2+=2; return 8}
  PC2 += 2+signedOffset2(readMem2(PC+1))
  return 12
}

function jrZ2(){
  if (!FLAGS2.Z) {PC2+=2; return 8}
  PC2 += 2+signedOffset2(readMem2(PC2+1));
  return 12
}

function jrC2(){
  if (!FLAGS2.C) {PC2+=2; return 8}
  PC2 += 2+signedOffset2(readMem2(PC2+1))
	return 12
}

function jr2(){ //unconditional relative
  PC2 += 2+signedOffset2(readMem2(PC2+1))
  return 12
}

function jp2(){ //unconditional absolute
  PC2 = readMem2(PC2+1)+(readMem(PC2+2)<<8)
  return 16
}
function jpNZ2(){
  if (FLAGS2.Z) {PC2+=3; return 12}
  PC2 = readMem2(PC2+1)+(readMem2(PC2+2)<<8)
  return 16
}
function jpNC2(){
  if (FLAGS2.C) {PC2+=3; return 12}
  PC2 = readMem2(PC2+1)+(readMem2(PC2+2)<<8)
  return 16
}
function jpZ2(){
  if (!FLAGS2.Z) {PC2+=3; return 12}
  PC2 = readMem2(PC2+1)+(readMem2(PC2+2)<<8)
  return 16
}
function jpC2(){
  if (!FLAGS2.C) {PC2+=3; return 12}
  PC2 = readMem2(PC2+1)+(readMem2(PC2+2)<<8)
  return 16
}

function jpHL2(){
  PC2 = (REG2[H]<<8)+REG2[L]
  return 4
}

function push2(a,b) {
  if (a==A) return function(){
    var flags = (FLAGS2.Z << 7) + (FLAGS2.N << 6) + (FLAGS2.H << 5) + (FLAGS2.C << 4)
    SP2 -=2
    writeMem162(SP2, REG2[A], flags)
    PC2++
    return 16
  }
  return function(){
    SP2-=2
    writeMem162(SP2, REG2[a], REG2[b])
    PC2++
    return 16
  }
}

function pop2(a,b) {
  if (a==A) return function(){
    var s = readMem162(SP);
    REG2[A] = s[0]
    FLAGS2.Z = (s[1] & (1<<7)) != 0
    FLAGS2.N = (s[1] & (1<<6)) != 0
    FLAGS2.H = (s[1] & (1<<5)) != 0
    FLAGS2.C = (s[1] & (1<<4)) != 0
    SP2+=2
    PC2++
    return 12
  }
  return function(){
    var s = readMem162(SP);
    REG2[a] = s[0]
    REG2[b] = s[1]
    SP2+=2
    PC2++
    return 12
  }
}

function call2(){
  SP2 -=2
  var npc = PC2+3
  writeMem162(SP2, npc>>8, npc&0xFF)
  PC2 = readMem2(PC2+1)+(readMem2(PC2+2)<<8)
  return 24
}
function callNZ2(){
  if (FLAGS2.Z) {PC2+=3; return 12}
  return call2()
}
function callNC2(){
  if (FLAGS2.C) {PC2+=3; return 12}
  return call2()
}
function callZ2(){
  if (!FLAGS2.Z) {PC2+=3; return 12}
  return call2()
}
function callC2(){
  if (!FLAGS2.C) {PC2+=3; return 12}
  return call2()
}

function ret2(){
  var s = readMem162(SP2);
  SP2+=2
  PC2 = (s[0]<<8)+s[1]
  return 16
}
function retNZ2(){
  if (FLAGS2.Z) {PC2++; return 8}
  ret2()
  return 20
}
function retNC2(){
  if (FLAGS2.C) {PC2++; return 8}
  ret2()
  return 20
}
function retZ2(){
  if (!FLAGS2.Z) {PC2++; return 8}
  ret2()
  return 20
}
function retC2(){
  if (!FLAGS2.C) {PC2++; return 8}
  ret2()
  return 20
}
function reti2(){
  IME2 = true
  return ret2()
}

function ei2(){
  // This needs to wait until the end of the next instruction
  IME2 = true
  PC2++
  return 4
}

function di2(){
  IME2 = false
  PC2++
  return 4
}

function rst2(a){
  return function(){
    SP2 -=2
    var npc = PC2+1 // datasheets say to push the current program counter, but surely it means the return address
    writeMem162(SP2, npc>>8, npc&0xFF)
    PC2 = a
    return 16
  }
}

function shift_fast2(op, a){
  return function(){
    REG2[a] = shift_process2(op, REG2[a])
    FLAGS2.Z=false // Bizarre, but correct
    PC2++
    return 4
  }
}

function shift2(op, a){
  if (a==HL) return function(){
    var addr= (REG2[H]<<8)+REG2[L];
    writeMem2( addr , shift_process2( op, readMem2(addr) ) )
    PC2++
    return 16
  }
  return function(){
    REG2[a] = shift_process2(op, REG2[a])
    PC2++
    return 8
  }
}

function shift_process2(op, a){

  var bit7 = a>>7, bit0 = a&1;

  switch (op) {
    case RLC: // Rotate byte left, save carry
      a = ((a<<1)&0xff) + bit7
      FLAGS2.C = !!bit7
    break;
    case RRC: // Rotate byte right, save carry
      a = ((a>>1)&0xff) + (bit0<<7)
      FLAGS2.C = !!bit0
    break;
    case RL : //Rotate left through carry
      a = ((a<<1)&0xff) + FLAGS.C 
      FLAGS2.C = !!bit7
    break;
    case RR : //Rotate right through carry
      a = ((a>>1)&0xff) + (FLAGS.C<<7)
      FLAGS2.C = !!bit0
    break;
    case SLA: //Shift left
      a = ((a<<1)&0xff)
      FLAGS2.C = !!bit7
    break;
    case SRA: //Shift right arithmetic
      a = ((a>>1)&0xff) + (bit7<<7)
      FLAGS2.C = !!bit0
    break;
    case SRL: //Shift right logical
      a = ((a>>1)&0xff)
      FLAGS2.C = !!bit0
    break;
  }

  FLAGS2.N=false
  FLAGS2.H=false
  FLAGS2.Z= (a&0xFF)==0
  return a
}

function ccf2(){
  FLAGS2.N =false
  FLAGS2.H =false
  FLAGS2.C =!FLAGS2.C
  PC2++
  return 4
}
function scf2(){
  FLAGS2.N =false
  FLAGS2.H =false
  FLAGS2.C =true
  PC2++
  return 4
}
function cpl2(){
  REG2[A] = ~REG2[A]
  FLAGS2.N =true
  FLAGS2.H =true
  PC2++
  return 4
}
function addHL2(a,b){
  if (a==SPr) return function(){
    var c = (REG2[L] += (SP2&0xFF))>255?1:0;
    var h = REG2[H] + (SP2>>8) + c
    FLAGS2.H = !!(((REG2[H]&0x0F) + ((SP2>>8)&0x0F) + c) & 0x10)
    REG2[H] = h;
    FLAGS2.C = (h>255)
    FLAGS2.N=false
    PC2++
    return 8
  }
  return function(){
    var c = (REG2[L]+= REG2[b])>255?1:0;
    var h = REG2[H] + REG2[a] + c
    FLAGS2.H = !!(((REG2[H]&0x0F) + (REG2[a]&0x0F) + c) & 0x10)
    REG2[H] = h;
    FLAGS2.C = (h>255)
    FLAGS2.N=false
    PC2++
    return 8
  }
}
function daa2(){
//http://gbdev.gg8.se/wiki/articles/DAA

  if (FLAGS2.N) {
    if (FLAGS2.C) REG2[A]-=0x60;
    if (FLAGS2.H) REG2[A]-=0x06;
  } else {
    if (       REG2[A]>0x99 || FLAGS2.C) {REG2[A]+=0x60; FLAGS2.C=true}
    if ((REG2[A]&0x0f)>0x09 || FLAGS2.H) REG2[A]+=0x06;
  }

  FLAGS2.Z = REG2[A] == 0
  FLAGS2.H = false

  PC2++
  return 4
}
function ld_imm_sp2(){
  writeMem162( readMem2(PC2+1)+(readMem2(PC2+2)<<8) , SP2>>8, SP2&0xFF );
  PC2+=3
  return 20
}
function ld_hl_spdd2(){
  var b = signedOffset2(readMem2(PC2+1));

  FLAGS2.H= !!(((SP2&0x0F) + (b&0x0F)) &0x010)
  FLAGS2.C= !!(((SP2&0xFF) + (b&0xFF)) &0x100)

  var n = SP2 + b
  REG2[H] =(n>>8)
  REG2[L] =n&0xFF

  FLAGS2.N=false
  FLAGS2.Z=false
  PC2+=2
  return 12
}
function add_sp_n2(){
  var b=signedOffset2(readMem2(PC2+1))

  FLAGS2.H= !!(((SP2&0x0F) + (b&0x0F)) &0x010)
  FLAGS2.C= !!(((SP2&0xFF) + (b&0xFF)) &0x100)

  SP2 += b
  FLAGS2.N=false
  FLAGS2.Z=false

  SP2&=0xFFFF
  PC2+=2
  return 16
}

function halt2() {
// if interrupts disabled, stall 1 cycle, skip next instruction and continue
  cpu_halted2=true;
  PC2++;
  return 4
}; 
function stop2(){
  //TODO
  PC2+=2;
  return 4
}


opcodes2[ 0x00 ] = function nop2(){ PC2++; return 4 };
opcodes2[ 0x01 ] = ld162(B,C,Immediate);
opcodes2[ 0x02 ] = ld_to_mem2(B,C,A);
opcodes2[ 0x03 ] = inc162(B,C);
opcodes2[ 0x04 ] = inc2(B);
opcodes2[ 0x05 ] = dec2(B);
opcodes2[ 0x06 ] = ld2(B, Immediate);
opcodes2[ 0x07 ] = shift_fast2(RLC, A) //rlca
opcodes2[ 0x08 ] = ld_imm_sp2; //LD   (nn),SP
opcodes2[ 0x09 ] = addHL2(B,C);
opcodes2[ 0x0A ] = ld_from_mem2(A, B, C);
opcodes2[ 0x0B ] = dec162(B,C);
opcodes2[ 0x0C ] = inc2(C);
opcodes2[ 0x0D ] = dec2(C);
opcodes2[ 0x0E ] = ld2(C, Immediate);
opcodes2[ 0x0F ] = shift_fast2(RRC, A);


opcodes2[ 0x10 ] = stop2;
opcodes2[ 0x11 ] = ld162(D,E,Immediate);
opcodes2[ 0x12 ] = ld_to_mem2(D,E,A);
opcodes2[ 0x13 ] = inc162(D,E);
opcodes2[ 0x14 ] = inc2(D);
opcodes2[ 0x15 ] = dec2(D);
opcodes2[ 0x16 ] = ld2(D, Immediate);
opcodes2[ 0x17 ] = shift_fast2(RL, A) 
opcodes2[ 0x18 ] = jr2;
opcodes2[ 0x19 ] = addHL2(D,E); //ADD HL, DE
opcodes2[ 0x1A ] = ld_from_mem2(A, D, E);
opcodes2[ 0x1B ] = dec162(D,E);
opcodes2[ 0x1C ] = inc2(E);
opcodes2[ 0x1D ] = dec2(E);
opcodes2[ 0x1E ] = ld2(E, Immediate);
opcodes2[ 0x1F ] = shift_fast2(RR, A);

opcodes2[ 0x20 ] = jrNZ2;
opcodes2[ 0x21 ] = ld162(H,L,Immediate);
opcodes2[ 0x22 ] = ldi2(HL,A);
opcodes2[ 0x23 ] = inc162(H,L);
opcodes2[ 0x24 ] = inc2(H);
opcodes2[ 0x25 ] = dec2(H);
opcodes2[ 0x26 ] = ld2(H, Immediate);
opcodes2[ 0x27 ] = daa2;
opcodes2[ 0x28 ] = jrZ2;
opcodes2[ 0x29 ] = addHL2(H,L);
opcodes2[ 0x2A ] = ldi2(A,HL);
opcodes2[ 0x2B ] = dec162(H,L);
opcodes2[ 0x2C ] = inc2(L);
opcodes2[ 0x2D ] = dec2(L);
opcodes2[ 0x2E ] = ld2(L, Immediate);
opcodes2[ 0x2F ] = cpl2;

opcodes2[ 0x30 ] = jrNC2;
opcodes2[ 0x31 ] = ld162(SPr, Immediate);
opcodes2[ 0x32 ] = ldd2(HL,A);
opcodes2[ 0x33 ] = inc162(SPr);
opcodes2[ 0x34 ] = inc2(HL);
opcodes2[ 0x35 ] = dec2(HL);
opcodes2[ 0x36 ] = ld_to_mem2(H,L,Immediate);
opcodes2[ 0x37 ] = scf2;
opcodes2[ 0x38 ] = jrC2;
opcodes2[ 0x39 ] = addHL2(SPr);
opcodes2[ 0x3A ] = ldd2(A,HL);
opcodes2[ 0x3B ] = dec162(SPr);
opcodes2[ 0x3C ] = inc2(A);
opcodes2[ 0x3D ] = dec2(A);
opcodes2[ 0x3E ] = ld2(A, Immediate);
opcodes2[ 0x3F ] = ccf2;


opcodes2[ 0x40 ] = ld2(B,B);
opcodes2[ 0x41 ] = ld2(B,C);
opcodes2[ 0x42 ] = ld2(B,D);
opcodes2[ 0x43 ] = ld2(B,E);
opcodes2[ 0x44 ] = ld2(B,H);
opcodes2[ 0x45 ] = ld2(B,L);
opcodes2[ 0x46 ] = ld_from_mem2(B, H, L );
opcodes2[ 0x47 ] = ld2(B,A);

opcodes2[ 0x48 ] = ld2(C,B);
opcodes2[ 0x49 ] = ld2(C,C);
opcodes2[ 0x4A ] = ld2(C,D);
opcodes2[ 0x4B ] = ld2(C,E);
opcodes2[ 0x4C ] = ld2(C,H);
opcodes2[ 0x4D ] = ld2(C,L);
opcodes2[ 0x4E ] = ld_from_mem2(C, H, L );
opcodes2[ 0x4F ] = ld2(C,A);

opcodes2[ 0x50 ] = ld2(D,B);
opcodes2[ 0x51 ] = ld2(D,C);
opcodes2[ 0x52 ] = ld2(D,D);
opcodes2[ 0x53 ] = ld2(D,E);
opcodes2[ 0x54 ] = ld2(D,H);
opcodes2[ 0x55 ] = ld2(D,L);
opcodes2[ 0x56 ] = ld_from_mem2(D, H, L );
opcodes2[ 0x57 ] = ld2(D,A);

opcodes2[ 0x58 ] = ld2(E,B);
opcodes2[ 0x59 ] = ld2(E,C);
opcodes2[ 0x5A ] = ld2(E,D);
opcodes2[ 0x5B ] = ld2(E,E);
opcodes2[ 0x5C ] = ld2(k,H);
opcodes2[ 0x5D ] = ld2(E,L);
opcodes2[ 0x5E ] = ld_from_mem2(E, H, L );
opcodes2[ 0x5F ] = ld2(E,A);

opcodes2[ 0x60 ] = ld2(H,B);
opcodes2[ 0x61 ] = ld2(H,C);
opcodes2[ 0x62 ] = ld2(H,D);
opcodes2[ 0x63 ] = ld2(H,E);
opcodes2[ 0x64 ] = ld2(H,H);
opcodes2[ 0x65 ] = ld2(H,L);
opcodes2[ 0x66 ] = ld_from_mem2(H, H, L );
opcodes2[ 0x67 ] = ld2(H,A);

opcodes2[ 0x68 ] = ld2(L,B);
opcodes2[ 0x69 ] = ld2(L,C);
opcodes2[ 0x6A ] = ld2(L,D);
opcodes2[ 0x6B ] = ld2(L,E);
opcodes2[ 0x6C ] = ld2(L,H);
opcodes2[ 0x6D ] = ld2(L,L);
opcodes2[ 0x6E ] = ld_from_mem2(L, H, L );
opcodes2[ 0x6F ] = ld2(L,A);

opcodes2[ 0x70 ] = ld_to_mem2(H,L, B);
opcodes2[ 0x71 ] = ld_to_mem2(H,L, C);
opcodes2[ 0x72 ] = ld_to_mem2(H,L, D);
opcodes2[ 0x73 ] = ld_to_mem2(H,L, E);
opcodes2[ 0x74 ] = ld_to_mem2(H,L, H);
opcodes2[ 0x75 ] = ld_to_mem2(H,L, L);
opcodes2[ 0x76 ] = halt2;
opcodes2[ 0x77 ] = ld_to_mem2(H,L, A);

opcodes2[ 0x78 ] = ld2(A,B);
opcodes2[ 0x79 ] = ld2(A,C);
opcodes2[ 0x7A ] = ld2(A,D);
opcodes2[ 0x7B ] = ld2(A,E);
opcodes2[ 0x7C ] = ld2(A,H);
opcodes2[ 0x7D ] = ld2(A,L);
opcodes2[ 0x7E ] = ld_from_mem2(A, H, L );
opcodes2[ 0x7F ] = ld2(A,A);

opcodes2[ 0x80 ] = ALU2(ADD,A,B);
opcodes2[ 0x81 ] = ALU2(ADD,A,C);
opcodes2[ 0x82 ] = ALU2(ADD,A,D);
opcodes2[ 0x83 ] = ALU2(ADD,A,E);
opcodes2[ 0x84 ] = ALU2(ADD,A,H);
opcodes2[ 0x85 ] = ALU2(ADD,A,L);
opcodes2[ 0x86 ] = ALU2(ADD,A, HL );
opcodes2[ 0x87 ] = ALU2(ADD,A,A);

opcodes2[ 0x88 ] = ALU2(ADC,A,B);
opcodes2[ 0x89 ] = ALU2(ADC,A,C);
opcodes2[ 0x8A ] = ALU2(ADC,A,D);
opcodes2[ 0x8B ] = ALU2(ADC,A,E);
opcodes2[ 0x8C ] = ALU2(ADC,A,H);
opcodes2[ 0x8D ] = ALU2(ADC,A,L);
opcodes2[ 0x8E ] = ALU2(ADC,A, HL );
opcodes2[ 0x8F ] = ALU2(ADC,A,A);

opcodes2[ 0x90 ] = ALU2(SUB,A,B);
opcodes2[ 0x91 ] = ALU2(SUB,A,C);
opcodes2[ 0x92 ] = ALU2(SUB,A,D);
opcodes2[ 0x93 ] = ALU2(SUB,A,E);
opcodes2[ 0x94 ] = ALU2(SUB,A,H);
opcodes2[ 0x95 ] = ALU2(SUB,A,L);
opcodes2[ 0x96 ] = ALU2(SUB,A, HL );
opcodes2[ 0x97 ] = ALU2(SUB,A,A);






opcodes2[ 0x98 ] = ALU2(SBC,A,B);
opcodes2[ 0x99 ] = ALU2(SBC,A,C);
opcodes2[ 0x9A ] = ALU2(SBC,A,D);
opcodes2[ 0x9B ] = ALU2(SBC,A,E);
opcodes2[ 0x9C ] = ALU2(SBC,A,H);
opcodes2[ 0x9D ] = ALU2(SBC,A,L);
opcodes2[ 0x9E ] = ALU2(SBC,A, HL );
opcodes2[ 0x9F ] = ALU2(SBC,A,A);

opcodes2[ 0xA0 ] = ALU2(AND,A,B);
opcodes2[ 0xA1 ] = ALU2(AND,A,C);
opcodes2[ 0xA2 ] = ALU2(AND,A,D);
opcodes2[ 0xA3 ] = ALU2(AND,A,E);
opcodes2[ 0xA4 ] = ALU2(AND,A,H);
opcodes2[ 0xA5 ] = ALU2(AND,A,L);
opcodes2[ 0xA6 ] = ALU2(AND,A, HL );
opcodes2[ 0xA7 ] = ALU2(AND,A,A);

opcodes2[ 0xA8 ] = ALU2(XOR,A,B);
opcodes2[ 0xA9 ] = ALU2(XOR,A,C);
opcodes2[ 0xAA ] = ALU2(XOR,A,D);
opcodes2[ 0xAB ] = ALU2(XOR,A,E);
opcodes2[ 0xAC ] = ALU2(XOR,A,H);
opcodes2[ 0xAD ] = ALU2(XOR,A,L);
opcodes2[ 0xAE ] = ALU2(XOR,A, HL );
opcodes2[ 0xAF ] = ALU2(XOR,A,A);

opcodes2[ 0xB0 ] = ALU2(OR,A,B);
opcodes2[ 0xB1 ] = ALU2(OR,A,C);
opcodes2[ 0xB2 ] = ALU2(OR,A,D);
opcodes2[ 0xB3 ] = ALU2(OR,A,E);
opcodes2[ 0xB4 ] = ALU2(OR,A,H);
opcodes2[ 0xB5 ] = ALU2(OR,A,L);
opcodes2[ 0xB6 ] = ALU2(OR,A, HL );
opcodes2[ 0xB7 ] = ALU2(OR,A,A);

opcodes2[ 0xB8 ] = ALU2(CP,A,B);
opcodes2[ 0xB9 ] = ALU2(CP,A,C);
opcodes2[ 0xBA ] = ALU2(CP,A,D);
opcodes2[ 0xBB ] = ALU2(CP,A,E);
opcodes2[ 0xBC ] = ALU2(CP,A,H);
opcodes2[ 0xBD ] = ALU2(CP,A,L);
opcodes2[ 0xBE ] = ALU2(CP,A, HL );
opcodes2[ 0xBF ] = ALU2(CP,A,A);

opcodes2[ 0xC0 ] = retNZ2;
opcodes2[ 0xC1 ] = pop2(B,C);
opcodes2[ 0xC2 ] = jpNZ2;
opcodes2[ 0xC3 ] = jp2;
opcodes2[ 0xC4 ] = callNZ2;
opcodes2[ 0xC5 ] = push2(B,C);
opcodes2[ 0xC6 ] = ALU2(ADD,A,Immediate);
opcodes2[ 0xC7 ] = rst2(0x00);
opcodes2[ 0xC8 ] = retZ2;
opcodes2[ 0xC9 ] = ret2;
opcodes2[ 0xCA ] = jpZ2;
opcodes2[ 0xCB ] = function(){ return CBCodes2[ readMem2( ++PC2 ) ](); }
opcodes2[ 0xCC ] = callZ2;
opcodes2[ 0xCD ] = call2;
opcodes2[ 0xCE ] = ALU2(ADC,A,Immediate);
opcodes2[ 0xCF ] = rst2(0x08);

opcodes2[ 0xD0 ] = retNC2;
opcodes2[ 0xD1 ] = pop2(D,E);
opcodes2[ 0xD2 ] = jpNC2;
opcodes2[ 0xD3 ] = unused2;
opcodes2[ 0xD4 ] = callNC2;
opcodes2[ 0xD5 ] = push2(D,E);
opcodes2[ 0xD6 ] = ALU2(SUB,A,Immediate);
opcodes2[ 0xD7 ] = rst2(0x10);
opcodes2[ 0xD8 ] = retC2;
opcodes2[ 0xD9 ] = reti2; //RETI
opcodes2[ 0xDA ] = jPC22;
opcodes2[ 0xDB ] = unused2;
opcodes2[ 0xDC ] = callC2;
opcodes2[ 0xDD ] = unused2;
opcodes2[ 0xDE ] = ALU2(SBC,A,Immediate);
opcodes2[ 0xDF ] = rst2(0x18);

opcodes2[ 0xE0 ] = ldh2(Immediate, A); //LD   (FF00+n),A
opcodes2[ 0xE1 ] = pop2(H,L);
opcodes2[ 0xE2 ] = ldc22(C, A); //LD   (FF00+C),A
opcodes2[ 0xE3 ] = unused2;
opcodes2[ 0xE4 ] = unused2;
opcodes2[ 0xE5 ] = push2(H,L);
opcodes2[ 0xE6 ] = ALU2(AND,A,Immediate);
opcodes2[ 0xE7 ] = rst2(0x20);
opcodes2[ 0xE8 ] = add_SP2_n; //ADD  SP2,dd
opcodes2[ 0xE9 ] = jpHL2;
opcodes2[ 0xEA ] = ld_to_mem2(Immediate, A); //LD   (nn),A
opcodes2[ 0xEB ] = unused2;
opcodes2[ 0xEC ] = unused2;
opcodes2[ 0xED ] = unused2;
opcodes2[ 0xEE ] = ALU2(XOR,A,Immediate);
opcodes2[ 0xEF ] = rst2(0x28);

opcodes2[ 0xF0 ] = ldh2(A, Immediate); //LD   A,(FF00+n)
opcodes2[ 0xF1 ] = pop2(A,FLAGS);
opcodes2[ 0xF2 ] =  ldc2(A, C); //LD   A,(FF00+C)
opcodes2[ 0xF3 ] = di2;
opcodes2[ 0xF4 ] = unused2;
opcodes2[ 0xF5 ] = push2(A, FLAGS);
opcodes2[ 0xF6 ] = ALU2(OR,A,Immediate);
opcodes2[ 0xF7 ] = rst2(0x30);
opcodes2[ 0xF8 ] = ld_hl_SP2dd2; //LD   HL,SP2+dd
opcodes2[ 0xF9 ] = ld162();
opcodes2[ 0xFA ] = ld_from_mem2(A, Immediate); //LD   A,(nn)
opcodes2[ 0xFB ] = ei2;
opcodes2[ 0xFC ] = unused2;
opcodes2[ 0xFD ] = unused2;
opcodes2[ 0xFE ] = ALU2(CP,A,Immediate);
opcodes2[ 0xFF ] = rst2(0x38);




CBCodes2[ 0x00 ] = shift2(RLC, B);
CBCodes2[ 0x01 ] = shift2(RLC, C);
CBCodes2[ 0x02 ] = shift2(RLC, D);
CBCodes2[ 0x03 ] = shift2(RLC, E);
CBCodes2[ 0x04 ] = shift2(RLC, H);
CBCodes2[ 0x05 ] = shift2(RLC, L);
CBCodes2[ 0x06 ] = shift2(RLC, HL );
CBCodes2[ 0x07 ] = shift2(RLC, A);
CBCodes2[ 0x08 ] = shift2(RRC, B);
CBCodes2[ 0x09 ] = shift2(RRC, C);
CBCodes2[ 0x0A ] = shift2(RRC, D);
CBCodes2[ 0x0B ] = shift2(RRC, E);
CBCodes2[ 0x0C ] = shift2(RRC, H);
CBCodes2[ 0x0D ] = shift2(RRC, L);
CBCodes2[ 0x0E ] = shift2(RRC, HL );
CBCodes2[ 0x0F ] = shift2(RRC, A);

CBCodes2[ 0x10 ] = shift2(RL, B);
CBCodes2[ 0x11 ] = shift2(RL, C);
CBCodes2[ 0x12 ] = shift2(RL, D);
CBCodes2[ 0x13 ] = shift2(RL, E);
CBCodes2[ 0x14 ] = shift2(RL, H);
CBCodes2[ 0x15 ] = shift2(RL, L);
CBCodes2[ 0x16 ] = shift2(RL, HL );
CBCodes2[ 0x17 ] = shift2(RL, A);
CBCodes2[ 0x18 ] = shift2(RR, B);
CBCodes2[ 0x19 ] = shift2(RR, C);
CBCodes2[ 0x1A ] = shift2(RR, D);
CBCodes2[ 0x1B ] = shift2(RR, E);
CBCodes2[ 0x1C ] = shift2(RR, H);
CBCodes2[ 0x1D ] = shift2(RR, L);
CBCodes2[ 0x1E ] = shift2(RR, HL );
CBCodes2[ 0x1F ] = shift2(RR, A);

CBCodes2[ 0x20 ] = shift2(SLA, B);
CBCodes2[ 0x21 ] = shift2(SLA, C);
CBCodes2[ 0x22 ] = shift2(SLA, D);
CBCodes2[ 0x23 ] = shift2(SLA, E);
CBCodes2[ 0x24 ] = shift2(SLA, H);
CBCodes2[ 0x25 ] = shift2(SLA, L);
CBCodes2[ 0x26 ] = shift2(SLA, HL );
CBCodes2[ 0x27 ] = shift2(SLA, A);
CBCodes2[ 0x28 ] = shift2(SRA, B);
CBCodes2[ 0x29 ] = shift2(SRA, C);
CBCodes2[ 0x2A ] = shift2(SRA, D);
CBCodes2[ 0x2B ] = shift2(SRA, E);
CBCodes2[ 0x2C ] = shift2(SRA, H);
CBCodes2[ 0x2D ] = shift2(SRA, L);
CBCodes2[ 0x2E ] = shift2(SRA, HL );
CBCodes2[ 0x2F ] = shift2(SRA, A);

CBCodes2[ 0x38 ] = shift2(SRL, B);
CBCodes2[ 0x39 ] = shift2(SRL, C);
CBCodes2[ 0x3A ] = shift2(SRL, D);
CBCodes2[ 0x3B ] = shift2(SRL, E);
CBCodes2[ 0x3C ] = shift2(SRL, H);
CBCodes2[ 0x3D ] = shift2(SRL, L);
CBCodes2[ 0x3E ] = shift2(SRL, HL );
CBCodes2[ 0x3F ] = shift2(SRL, A);




	
	

function swap2(r){
  if (r==HL) return function(){
    var a = readMem2( (REG2[H]<<8)+REG2[L] );
    a = (a>>4) + ((a<<4)&0xFF);
    writeMem2( (REG2[H]<<8)+REG2[L] , a ); 
    FLAGS2.Z = (a==0)
    FLAGS2.N =false
    FLAGS2.H =false
    FLAGS2.C =false
    PC2++
    return 16
  }
  return function (){
    REG2[r] = (REG2[r]>>4) + ((REG2[r]<<4)&0xFF)
    FLAGS2.Z = (REG2[r]==0)
    FLAGS2.N =false
    FLAGS2.H =false
    FLAGS2.C =false
    PC2++
    return 8
  }
}

CBcodes2[ 0x30 ] = swap2(B);
CBcodes2[ 0x31 ] = swap2(C);
CBcodes2[ 0x32 ] = swap2(D);
CBcodes2[ 0x33 ] = swap2(E);
CBcodes2[ 0x34 ] = swap2(H);
CBcodes2[ 0x35 ] = swap2(L);
CBcodes2[ 0x36 ] = swap2(HL);
CBcodes2[ 0x37 ] = swap2(A);

function bit2(b, r) {
  b = (1<<b);

  if (r==HL) return function(){
    FLAGS2.Z = ((readMem2((REG2[H]<<8)+REG2[L]) & b) == 0)
    FLAGS2.H = true;
    FLAGS2.N = false;
    PC2++
    return 12
  }
  return function(){
    FLAGS2.Z = ((REG2[r] & b) == 0)
    FLAGS2.H = true;
    FLAGS2.N = false;
    PC2++
    return 8
  }
}
function set2(b, r) {
  b = (1<<b);

  if (r==HL) return function(){
    writeMem2(
      (REG2[H]<<8)+REG2[L],
      readMem((REG2[H]<<8)+REG2[L]) | b
    )
    PC2++
    return 16
  }
  return function(){
    REG2[r] |= b
    PC2++
    return 8
  }
}
function res2(b, r) {
  b = ~(1<<b);

  if (r==HL) return function(){
    writeMem2(
      (REG2[H]<<8)+REG2[L],
      readMem2((REG2[H]<<8)+REG2[L]) & b
    )
    PC2++
    return 16
  }
  return function(){
    REG2[r] &= b
    PC2++
    return 8
  }
}

for (var i=0;i<8;i++){
  for (var j=0;j<8;j++) {
    CBcodes2[ 0x40 + i*8 + j ] = bit2(i, j);
    CBcodes2[ 0x80 + i*8 + j ] = res2(i, j);
    CBcodes2[ 0xC0 + i*8 + j ] = set2(i, j);
  }
}



var bootCode2 = "31 FE FF AF 21 FF 9F 32 CB 7C 20 FB 21 26 FF 0E 11 3E 80 32 E2 0C 3E F3 E2 32 3E 77 77 3E FC E0 47 11 04 01 21 10 80 1A CD 95 00 CD 96 00 13 7B FE 34 20 F3 11 D8 00 06 08 1A 13 22 23 05 20 F9 3E 19 EA 10 99 21 2F 99 0E 0C 3D 28 08 32 0D 20 F9 2E 0F 18 F3 67 3E 64 57 E0 42 3E 91 E0 40 04 1E 02 0E 0C F0 44 FE 90 20 FA 0D 20 F7 1D 20 F2 0E 13 24 7C 1E 83 FE 62 28 06 1E C1 FE 64 20 06 7B E2 0C 3E 87 E2 F0 42 90 E0 42 15 20 D2 05 20 4F 16 20 18 CB 4F 06 04 C5 CB 11 17 C1 CB 11 17 05 20 F5 22 23 22 23 C9 CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D 00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99 BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E 3C 42 B9 A5 B9 A5 42 3C 21 04 01 11 A8 00 1A 13 BE 20 FE 23 7D FE 34 20 F5 06 19 78 86 23 05 20 FB 86 20 FE 3E 01 E0 50".split(" ").map(x => parseInt(x,16))



function sweepCalculate2(){
  //If the result of this formula is a value consisting of more than 11 bits, sound output is stopped and the Sound 1 ON flag of NR52 (bit 0) is reset.
  //In a subtraction operation, if the subtrahend is less than 0, the result is the pre-calculation value X (t ) = X ( t - 1 ). However, if n = 0, shifting does not occur and the frequency is unchanged.

  if (sound2[1].sweepDir) {
    sound2[1].freqnum += (sound2[1].freqnum >> sound2[1].sweepShift);
    if (sound2[1].freqnum>0x7ff) {
      sound2[1].initialized=false;
      MEM2[0xFF26] &= ~(1<<0) // flag sound 1 as off
      sound2[1].amp(0)
    } else sound2[1].freq( 131072/(2048-sound2[1].freqnum) )
  } else {
    sound2[1].freqnum -= (sound2[1].freqnum >> sound2[1].sweepShift);
    if (sound2[1].freqnum<0) sound2[1].freqnum += (sound2[1].freqnum >> sound2[1].sweepShift);
    sound2[1].freq( 131072/(2048-sound2[1].freqnum) )
  }
}


var soundPrescaler12=0, soundPrescaler22=0;
function soundStep2(){ //256 times per second
  if (!SoundEnabled2) return;

  // length resolution 1/256 second

  // Sound length = (64 - t1) x (1/256) sec

  if (sound2[1].lengthEnabled) {
    if (--sound2[1].length <=0) {
      sound2[1].lengthEnabled=false;
      sound2[1].initialized=false;
      sound2[1].amp(0)
      MEM2[0xFF26] &= ~(1<<0) // flag sound 1 as off
    }
  }
  if (sound2[2].lengthEnabled) {
    if (--sound2[2].length <=0) {
      sound2[2].lengthEnabled=false;
      sound2[2].initialized=false;
      sound2[2].amp(0)
      MEM2[0xFF26] &= ~(1<<1) // flag sound 2 as off
    }
  }
  if (sound2[3].lengthEnabled) {
    if (--sound2[3].length <=0) {
      sound2[3].lengthEnabled=false;
      sound2[3].initialized=false;
      sound2[3].amp(0)
      MEM2[0xFF26] &= ~(1<<2) // flag sound 3 as off
    }
  }
  if (sound2[4].lengthEnabled) {
    if (--sound2[4].length <=0) {
      sound2[4].lengthEnabled=false;
      sound2[4].initialized=false;
      sound2[4].amp(0)
      MEM2[0xFF26] &= ~(1<<3) // flag sound 4 as off
    }
  }


  if (soundPrescaler12++) {
    soundPrescaler12=0;
    // sweep resolution 1/128 second

    if (sound2[1].initialized && sound2[1].sweepTime ) {
      if (--sound2[1].sweepPrescaler2<0) {
        sound2[1].sweepPrescaler2 += sound2[1].sweepTime;
        sweepCalculate2();
      }
    }

    if (soundPrescaler22++) {
      soundPrescaler22=0;
      // envelope resolution 1/64 second

      for (var i of [1,2,4]) {

        if (sound2[i].initialized&&sound2[i].envSpeed) {
          // counter is reset when speed changes
          if(++sound2[i].envCounter == sound2[i].envSpeed) {
            sound2[i].envCounter=0;

            sound2[i].env += sound2[i].envDirection;
            if (sound2[i].env <= 0){
              sound2[i].env=0;
              sound2[i].initialized=false;
            }else if (sound2[i].env >= 15) {
              sound2[i].env=15;
              sound2[i].initialized=false;
            }
          
            sound2[i].amp( sound2[i].env/15 )
          }
        }

      }

    }
  }


//The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

  

}






function triggerInterrupt2(vector){
  cpu_halted2=false
  writeMem162(SP2-=2, PC2>>8, PC2&0xFF)
  PC2 = vector; 
  IME2=false

  return 20
}


function cpu2(){

  var cycles2 =4;

  if (!cpu_halted2) {
    cycles2 = opcodes2[readMem2(PC2)]();
  }
  
  // DIV  = 0xFF04 //Divider Register (R/W)
  // TIMA = 0xFF05 //Timer counter (R/W)
  // TMA  = 0xFF06 //Timer Modulo (R/W)
  // TAC  = 0xFF07 //Timer Control (R/W)

  //DIV register
  // Seems to be running very slightly faster than BGB, possibly 
  // some instructions are returning the wrong number
  if ((divPrescaler2 += cycles2) >255) {
    divPrescaler2-=256
    MEM2[0xFF04]++;
  }
  if (timerEnable2){
    timerPrescaler2-= cycles2
    while (timerPrescaler2<0) {
      timerPrescaler2+=timerLength2;
      if (MEM2[0xFF05]++ ==0xFF) {
        MEM2[0xFF05]=MEM2[0xFF06];
        // Set interrupt flag here
        MEM2[0xFF0F] |= 1<<2;
        cpu_halted2 = false
      }
    }
  }


  // FF41 - STAT - LCDC Status (R/W)
  // FF42 - SCY - Scroll Y (R/W)
  // FF43 - SCX - Scroll X (R/W)
  // FF44 - LY - LCDC Y-Coordinate (R)
  // FF45 - LYC - LY Compare (R/W)
  // FF46 - DMA - DMA Transfer and Start Address (W)
  // FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only
  // FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
  // FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
  // FF4A - WY - Window Y Position (R/W)
  // FF4B - WX - Window X Position minus 7 (R/W)

  // Complete scan line takes 456 clks.

  //  Mode 0 H-blank period        - 204 clks
  //  Mode 1 V-blank period        - 4560 clks
  //  Mode 2 Reading OAM           - 80 clks
  //  Mode 3 Reading OAM and VRAM  - 172 clks
  //
  //  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  //  Mode 3  _33____33____33____33____33____33__________________3___
  //  Mode 0  ___000___000___000___000___000___000________________000
  //  Mode 1  ____________________________________11111111111111_____

  if (LCD_enabled2){
    LCD_scan2 += cycles2;
    
    var mode=0, coincidence=false, draw=false;
    if (LCD_scan2 <= 80) mode = 2
    else if (LCD_scan2 <= 252) mode = 3
    else if (LCD_scan2 < 456) {
      draw = (LCD_lastmode2!=0)
      mode = 0
    } else {
      mode = 2
      LCD_scan2 -= 456;
      MEM2[0xFF44] ++;
      if (MEM2[0xFF44] > 153) MEM2[0xFF44] =0;
      coincidence = (MEM2[0xFF44] == MEM2[0xFF45]);
    }

    if (MEM2[0xFF44] >= 144) mode = 1; //vblank
    else if (draw){
      //Draw scanline
      var LY = MEM2[0xFF44];
      var dpy = LY*160;

      var drawWindow = (MEM2[0xFF40] & (1<<5)) && LY >= MEM2[0xFF4A];
      var bgStopX = drawWindow ? MEM2[0xFF4B]-7 : 160;

      //  FF40 - LCDC - LCD Control (R/W)
      //
      //  Bit 7 - LCD Display Enable             (0=Off, 1=On)
      //  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
      //  Bit 5 - Window Display Enable          (0=Off, 1=On)
      //  Bit 4 - BG & Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
      //  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
      //  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
      //  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
      //  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

      var baseTileOffset, tileSigned;
      // Tile Data Select
      if (MEM2[0xFF40]&(1<<4)) {
        baseTileOffset =  0x8000;
        tileSigned = false;
      } else {
        baseTileOffset =  0x9000;
        tileSigned = true;
      }
      var bgpalette = [
        (MEM2[0xFF47])&3,
        (MEM2[0xFF47]>>2)&3,
        (MEM2[0xFF47]>>4)&3,
        (MEM2[0xFF47]>>6)&3
      ]

      function grabTile2(n, offset){
        if (tileSigned2 && n >127){
          var tileptr = offset+(n-256)*16;
        }else{
          var tileptr = offset+n*16;
        }
        var d1 = MEM2[tileptr ], d2 = MEM2[tileptr +1]
        return pixelDecoder2[d1][d2]
      }

      if ( MEM2[0xFF40] & 1 ) { // BG enabled
        // BG Tile map display select
        var bgTileMapAddr = MEM2[0xFF40]&(1<<3) ? 0x9C00 : 0x9800;

        //scy FF42
        //scx FF43
        // scanline number FF44
        // pixel row = FF44 + FF42
        // tile row = pixel row >> 3
        // 32 bytes per row
        // pixel column = FF43
        // tile column = pixel column >> 3
        
        var x    = MEM2[0xFF43] >>3;
        var xoff = MEM2[0xFF43] & 7;
        var y = (LY + MEM2[0xFF42]) &0xFF;

        // Y doesn't change throughout a scanline
        bgTileMapAddr += (~~(y/8))*32; 
        var tileOffset=baseTileOffset+(y&7)*2;

        var pix = grabTile2(MEM2[ bgTileMapAddr + x ], tileOffset);

        for (var i=0;i<bgStopX;i++) {
          dpixels2[dpy + i] = bgpalette2[pix[ xoff++ ]]

          if (xoff==8) {
            x = (x+1)&0x1F; //wrap horizontally in tile map

            pix = grabTile2(MEM2[ bgTileMapAddr + x ], tileOffset);
            xoff=0;
          }

        }
      }

      // FF4A - WY
      // FF4B - WX

      if ( drawWindow ) { // Window display enable
        // Window Tile map display select
        var wdTileMapAddr = MEM2[0xFF40]&(1<<6) ? 0x9C00 : 0x9800;

        var xoff=0;
        var y=LY-MEM2[0xFF4A];

        wdTileMapAddr += (~~(y/8))*32; 
        var tileOffset=baseTileOffset+(y&7)*2;

        pix = grabTile2(MEM2[ wdTileMapAddr ], tileOffset);

        for (var i=Math.max(0,bgStopX);i<160;i++) {
          dpixels2[dpy + i] = bgpalette2[pix[ xoff++ ]]
          if (xoff==8) {
            pix = grabTile2(MEM2[ ++wdTileMapAddr ], tileOffset);
            xoff=0;
          }
        }

      }

      if ( MEM2[0xFF40] & 2 ) { // Sprite display enabled
        
        // Render sprites
        var height, tileNumMask;
        if (MEM2[0xFF40]&(1<<2)) {
          height=16;
          tileNumMask=0xFE; // in 8x16 mode, lowest bit of tile number is ignored
        } else {
          height=8;
          tileNumMask=0xFF; 
        }

        var OBP0 = [
          0,
          (MEM2[0xFF48]>>2)&3,
          (MEM2[0xFF48]>>4)&3,
          (MEM2[0xFF48]>>6)&3
        ],
        OBP1 = [
          0,
          (MEM2[0xFF49]>>2)&3,
          (MEM2[0xFF49]>>4)&3,
          (MEM2[0xFF49]>>6)&3
        ],
        background=bgpalette2[0];

        // OAM 4 bytes per sprite, 40 sprites
        for (var i=0xFE9C;i>=0xFE00;i-=4) {
          var ypos = MEM2[i]-16+height;
          if ( LY >= ypos-height && LY < ypos) {

            var tileNum = 0x8000 + (MEM2[i+2]&tileNumMask)*16,
                xpos = MEM2[i+1],
                att = MEM2[i+3];
            
            // Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
            //        (Used for both BG and Window. BG color 0 is always behind OBJ)
            // Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
            // Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
            // Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)

            var palette = att&(1<<4) ? OBP1 : OBP0 ;
            var behind = att&(1<<7);
            
            if (att&(1<<6)) { // Y flip
              tileNum += (ypos-LY-1)*2 
            }else{
              tileNum += (LY-ypos+height)*2 
            }
            var d1= MEM2[tileNum], d2= MEM2[tileNum+1],
              row = pixelDecoder2[d1][d2];

            if (att&(1<<5)) { // x flip
              if (behind) {
                for (var j = 0; j<Math.min(xpos,8); j++) {
                  if (dpixels2[dpy + xpos -1 - j] == background && row[j]) 
                    dpixels2[dpy + xpos -1 - j] = palette[row[ j ]];
                }
              }else{
                for (var j = 0; j<Math.min(xpos,8); j++) {
                  if (row[ j ]) dpixels2[dpy + xpos -(j+1)] = palette[row[ j ]];
                }
              }
            } else {
              if (behind) { 
                for (var j = Math.max(8-xpos,0); j<8; j++) {
                  if (dpixels2[dpy + xpos -8 + j] == background && row[j]) 
                    dpixels2[dpy + xpos -8 + j] = palette[row[ j ]];
                }
              } else {
                for (var j = Math.max(8-xpos,0); j<8; j++) {
                  if (row[ j ]) dpixels2[dpy + xpos -8 + j] = palette[row[ j ]];
                }
              }
            }

          }
        }

      }

    }

    //  0xFF41 - LCDC Status
    //  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
    //  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
    //  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
    //  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
    //  Bit 2 - Coincidence Flag  (0:LYC<>LY, 1:LYC=LY) (Read Only)

    if (coincidence){
      if (MEM2[0xFF41] & (1<<6)) { //coincidence interrupt enabled
        MEM2[0xFF0F] |= 1<<1; // LCD STAT Interrupt flag
        MEM2[0xFF41] |= 1<<2; // coincidence flag
      }
    } else MEM2[0xFF41] &= 0xFB//~(1<<2)
    if (LCD_lastmode2!=mode) { //Mode change
      if (mode == 0) {
        if (MEM2[0xFF41] & (1<<3)) MEM2[0xFF0F] |= 1<<1;
      } else if (mode == 1) {

        // LCD STAT interrupt on v-blank
        if (MEM2[0xFF41] & (1<<4)) MEM2[0xFF0F] |= 1<<1;

        // Main V-Blank interrupt
        if (MEM2[0xFFFF] & 1) MEM2[0xFF0F] |= 1<<0;

        renderDisplayCanvas2();

      } else if (mode == 2){
        if (MEM2[0xFF41] & (1<<5)) MEM2[0xFF0F] |= 1<<1;
      }

      MEM2[0xFF41] &= 0xF8;
      MEM2[0xFF41] += mode;
      LCD_lastmode2=mode;
    }

  }

  // Interrupts
  // FFFF - IE - Interrupt Enable (R/W)
  // FF0F - IF - Interrupt Flag (R/W)
  // Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  // Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  // Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  // Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  // Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)

  if (IME2) {
    // if enabled and flag set
    var i = MEM2[0xFF0F] & MEM2[0xFFFF];

    if ( i&(1<<0) ) { 
      MEM2[0xFF0F] &=~(1<<0)
      cycles2 += triggerInterrupt2(0x40)
    } else if ( i&(1<<1) ) {
      MEM2[0xFF0F] &=~(1<<1)
      cycles2 += triggerInterrupt2(0x48)
    } else if ( i&(1<<2) ) {
      MEM2[0xFF0F] &=~(1<<2)
      cycles2 += triggerInterrupt2(0x50)
    } else if ( i&(1<<3) ) {
      MEM2[0xFF0F] &=~(1<<3)
      cycles2 += triggerInterrupt2(0x58)
    } else if ( i&(1<<4) ) {
      MEM2[0xFF0F] &=~(1<<4)
      cycles2 += triggerInterrupt2(0x60)
    }

  } //else cpu_halted=false

  return cycles2
}


var requestStop2 = true;
var targ2=0x40 //v-blank
function runto2(end){
  if (!requestStop2) return
  if (ROM2.length<1000) return //don't run if no rom loaded

  
  requestStop2 =false;

  targ=end?end:parseInt(prompt('Address', f(targ,4)),16); 

  run2()
}

const soundStepClocks2 = 4194304/256;
const frameClocks2 = 4194304/59.7;
const frameIntervalMs2 = 1000/59.7;
var soundStepCountdown2 = soundStepClocks;
var frameCountdown2 = frameClocks;
var thisFrame2, lastFrame2 = performance.now();

function run2(time){
  thisFrame2 = time || performance.now()
  if (limitFrameRate2){
    let d = thisFrame2 - lastFrame2
    if (d >= frameIntervalMs2 - 0.1) {
      lastFrame2 = thisFrame2 - (d % frameIntervalMs2)
    } else {
      requestAnimationFrame(run2);
      return
    }
  }

  while (true){
    var cycles2 = cpu2();
    soundStepCountdown2 -= cycles2;
    frameCountdown2 -= cycles2;

    if (soundStepCountdown2 < 0){
      soundStepCountdown2 += soundStepClocks2;
      soundStep2();
    }
    if (frameCountdown2 < 0){
      frameCountdown2 += frameClocks2;
      break;
    }
    if (PC2 == targ) break;
  }

  if (PC2 != targ && !requestStop2) {
    if (limitFrameRate2){
      window.requestAnimationFrame(run2);
    }else{
      frameCountdown2+=frameClocks2*2 //this can go much higher
      window.setTimeout(run2, 0);
    }
  } else {
    requestStop2=true
    sound2[1].amp(0);
    sound2[2].amp(0);
    sound2[3].amp(0);
    sound2[4].amp(0);
  }
  if (debugOn2) debugData2()
}













var debugOn2=false;
function showDebug2(on){
  debugOn2 = on;
  document.getElementById('dbg2').style.display= on?'block':'none';
  if (on) debugData2();
}


function ascii2(c){
  return ".................................!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~.€.‚ƒ„…†‡ˆ‰Š‹Œ.Ž..‘’“”•–—˜™š›œ.žŸ ¡¢£¤¥¦§¨©ª«¬.®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ".charAt(c)
  .replace(/</g, '&lt;').replace(/>/g, '&gt;')
}

function f(a,l) {return ("0000"+a.toString(16).toUpperCase()).slice(-l||-2)}
(debugData2=function(){

  var debugOffset2 = PC2&0xFF00;
  var debug2 = "";
  for (var j=0;j<16;j++) {

    debug2+= "$"+f(debugOffset2 + j*16,4)+"   "
    for (var i=0;i<16;i++) {
      var q=i+j*16 + debugOffset2;
      debug2+="<span title='$"+ f(q,4) +"'"
      debug2+= PC==q ? " style='color:red'>":">"
      debug2+=f(readMem2(q))+"</span>"
 
      debug2+=(i==7?"|":" ")
      
    }
    debug2+="|  "
    for (var i=0;i<16;i++) {
      var c=readMem2(i+j*16 + debugOffset2)
      debug2+= ascii2(c);
    }
    
    
    debug2+="\n"
  }


  debug2+="\nAF: "+ f(REG2[A]) + f((FLAGS2.Z << 7) + (FLAGS2.N << 6) + (FLAGS2.H << 5) + (FLAGS2.C << 4))+"        Z: "+FLAGS2.Z
  debug2+="\nBC: "+ f(REG2[B])+ f(REG2[C])+"        N: "+FLAGS2.N
  debug2+="\nDE: "+ f(REG2[D])+ f(REG2[E])+"        H: "+FLAGS2.H
  debug2+="\nHL: "+ f(REG2[H])+ f(REG2[L])+"        C: "+FLAGS2.C
  debug2+="\nSP: "+ f(SP2,4)
  debug2+="\nPC: "+ f(PC2,4)
  debug2+="\n\nIME:"+IME2

  document.getElementById('out2').innerHTML=debug2;

  debug2=""
  for (var i in ioMap) {
    var r=f(readMem2(i));
    debug2+="$"+f(i*1,4)+": "+(r==0?"--":r)+" - "+ioMap[i]+" \n"
  }
  document.getElementById('io2').innerHTML=debug2

  debug2=""
  for (var i=SP2+20;i>=SP2-20;i-=2) {
    if (i>0xfffe || i<0) {debug2+=" ----  ----\n"}else{
      var r=f(readMem2(i+1)) + f(readMem2(i));
      debug2+="$"+f(i,4)+": "+r+(i==SP2?"*":"")+" \n"
    }
  }
  document.getElementById('stack2').innerHTML=debug2

})();



var openFile2 = function(event) {
  var input = event.target;
  var reader = new FileReader();
  reader.onload = function(){
    ROM2 = new Uint8Array(reader.result);
    FirstROMPage2 = ROM2.slice(0,256)

    //Overwrite first page with bootcode
    for (var i=0;i<256;i++) ROM2[i]=bootCode2[i];

    // According to BGB
    MEM2[0xFF41] = 1
    MEM2[0xFF43] = 0

    resetSoundRegisters2()

    ROMbank2 = 1; ROMbankoffset2 = (ROMbank2-1)*0x4000;
    RAMbank2 =0; RAMbankoffset2 = RAMbank2*0x2000 - 0xA000;
    RAMenabled2=false; MBCRamMode2=0;
    divPrescaler2=0, timerPrescaler2=0, timerLength2=1, timerEnable2=false;
    LCD_enabled2 = false, LCD_lastmode2=1, LCD_scan2=0;
    PC2=0, SP2=0,IME2=false,cpu_halted2=false;

    
  };
  reader.readAsArrayBuffer(input.files[0]);
};


var fileinput2=document.getElementById("fileinput2");
var start2=document.getElementById("start2");








function onlineSaveSram2(){
  var len = [0,2,8,32,128,64][ROM2[0x149]]*1024;
  if (ROM2[0x147]==5 || ROM2[0x147]==6) len=512; //MBC2
  ascii = btoa(String.fromCharCode(...cartRAM2.slice(0,len)));
  pass = prompt("自定义存档码(要记得，不要留空):");
  if (pass==""){ return "" }
  dbWrite(db,pass,ascii);
}
function onlineLoadSram2(){
  const dbRef = db.ref();
  let key = prompt("输入存档码:")
  dbRef.child(key).get().then((snapshot) => {
  if (snapshot.exists()) {
    loadascii2(snapshot.val())
  } else {
    alert("找不到存档")
  }}).catch((error) => {
    console.error(error);
  });
}
function loadascii2(ascii){
  decode = atob(ascii);
  chars = new Uint8Array();
  for(let i = 0;i < decode.length;i++){
    char = decode.charCodeAt(i);
    console.log(char);
    chars = appendlist(chars,char);
  }
  console.log(chars);
  cartRAM2 = chars;
}
	
	
function saveSram2(a){
  a.download=fileinput2.files[0].name.replace(/\.gbc?$/,'.sav')
  var len = [0,2,8,32,128,64][ROM2[0x149]]*1024

  if (ROM2[0x147]==5 || ROM2[0x147]==6) len=512; //MBC2
  console.log(btoa(String.fromCharCode(...cartRAM2.slice(0,len))))
  a.href='data:application/octet-stream;base64,'+btoa(String.fromCharCode(...cartRAM2.slice(0,len)))
}
	
function loadSram2(e) {
  var reader = new FileReader();
  reader.onload = function(){ cartRAM2 = new Uint8Array(reader.result); };
  reader.readAsArrayBuffer(e.target.files[0]);
}




	
	
function saveState2(){
  localStorage.savestate2= JSON.stringify({
    PC:PC2,
    SP:SP2,
    REG: REG2.join(),
    FLAGS: FLAGS2,
    IME:IME2,
    cpu_halted:cpu_halted2,
    MEM: MEM2.join(),
    //ROM: ROM2,  //too big for localstorage
    ROMbank: ROMbank2,
    ROMbankoffset:ROMbankoffset2,
    cartRAM: cartRAM2.join(),
    RAMbank: RAMbank2,
    RAMbankoffset: RAMbankoffset2,
    MBCRamMode: MBCRamMode2,
    LCD_enabled: LCD_enabled2,
    LCD_lastmode: LCD_lastmode2
  })
}
function loadState2(){
  if (!localStorage.savestate2) return
  for (var i=0;i<256;i++) ROM2[i]=FirstROMPage2[i];
  var all=JSON.parse(localStorage.savestate2);
  MEM2 = Uint8Array.from(all.MEM.split(","));
  PC2=all.PC;
  SP2=all.SP;
  REG2=Uint8Array.from(all.REG.split(","));
  FLAGS2=all.FLAGS;
  IME2=all.IME;
  cpu_halted2=cpu_halted;
  //rom=rom
  ROMbank2= all.ROMbank;
  ROMbankoffset2= all.ROMbankoffset;
  cartRAM2= Uint8Array.from(all.cartRAM.split(","));
  RAMbank2= all.RAMbank;
  RAMbankoffset2= all.RAMbankoffset;
  MBCRamMode2= all.MBCRamMode;
  LCD_enabled2= all.LCD_enabled;
  LCD_lastmode2= all.LCD_lastmode;
}




function insertInput2(myFile) {
  const dataTransfer = new DataTransfer();
  dataTransfer.items.add(myFile);
  fileinput2.files = dataTransfer.files;
}

function trigger2(){
  if ("createEvent" in document) {
    var evt = document.createEvent("HTMLEvents");
    evt.initEvent("change", false, true);
    fileinput2.dispatchEvent(evt);
  }
  else
    fileinput2.fireEvent("onchange");
}
if (fileinput2.files.length) openFile({"target":{"files":fileinput2.files}})
function loadbinarytorom2(bin){
    ROM2 = bin;
    FirstROMPage2 = ROM2.slice(0,256)

    //Overwrite first page with bootcode
    for (var i=0;i<256;i++) ROM2[i]=bootCode2[i];

    // According to BGB
    MEM2[0xFF41] = 1
    MEM2[0xFF43] = 0

    resetSoundRegisters2()

    ROMbank2 = 1; ROMbankoffset2 = (ROMbank2-1)*0x4000;
    RAMbank2 =0; RAMbankoffset2 = RAMbank2*0x2000 - 0xA000;
    RAMenabled2=false; MBCRamMode2=0;
    divPrescaler2=0, timerPrescaler2=0, timerLength2=1, timerEnable2=false;
    LCD_enabled2 = false, LCD_lastmode2=1, LCD_scan2=0;
    PC2=0, SP2=0,IME2=false,cpu_halted2=false;

}
function triggerstart(){
    if ("createEvent" in document) {
    var evt2 = document.createEvent("HTMLEvents");
    evt2.initEvent("click", false, true);
    start2.dispatchEvent(evt2);
  }
  else
    start2.fireEvent("onclick");
}
function useOnlineRom2(){
    alert("OnlineRomSelections");
    sel = [["red","blue","green","yellow"]];
    ser = ["pkmn"];
    lan = ["zh","eng"];
    series = select("选择系列: \n 1:宝可梦",["1"]);
    version = select("选择版本: \n " + sel[parseInt(series)-1].map((e, i) => String(i + 1) + ":" + String(e)).join(" \n "),rangeStr(sel[parseInt(series)-1].length));
    language = select("选择语言: \n 1:中文 \n 2:英文",["1","2"]);
    readUrl2("https://carlostmgps.github.io/emulator/gameboy/" + ser[series-1] + "_" + sel[series - 1][version - 1] + "_" + lan[language - 1] + ".gb");
    triggerstart2()
}

async function readUrl2(Url){
    fileget = await UrlFile(Url,"load.gb");
    console.log(Url);
    insertInput2(fileget);
    trigger2();
}



</script>

<br><br>
