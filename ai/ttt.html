<html>
<body>
    <div id="main">
        <h1>TIC TAC TOE</h1>
        <p id="ins">
            Tap on a box to play.<br><br>
            <b>Player X</b> starts first, followed by <b>Player O</b>.
        </p>
        <div id="board" class="board"></div>
        <br>
        <button id="reset" class="reset">RESET</button>
        <p id="message" class="message"></p>
    </div>
</body>

<head>
    <style>
      body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #f8f9fa;
}

#main {
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    border-radius: 10px;
    background-color: #ffffff;
}

.board {
    display: grid;
    grid-template-columns: repeat(3, 100px);
    grid-gap: 5px;
    margin-top: 20px;
}

.cell {
    width: 100px;
    height: 100px;
    border: 1px solid gray;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    cursor: pointer;
}

.cell.taken {
    pointer-events: none;
}

.message {
    margin-top: 20px;
    font-size: 18px;
    font-weight: bold;
}

.reset {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    background-color: whitesmoke;
    border: 1px solid dodgerblue;
    color: dodgerblue;
    border-radius: 8px;
}

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/synaptic/1.1.4/synaptic.js"></script>
    <script defer>
      const { Layer, Network } = window.synaptic;
      var inputLayer = new Layer(9);
      var hiddenLayer = new Layer(91);
      var hiddenLayer2 = new Layer(91);
      var outputLayer = new Layer(9);
      function download(data) {
  const file = new File([data], 'Network.txt', {
  type: 'text/plain',
  })
  const link = document.createElement('a')
  const url = URL.createObjectURL(file)

  link.href = url
  link.download = file.name
  document.body.appendChild(link)
  link.click()

  document.body.removeChild(link)
  window.URL.revokeObjectURL(url)
}
      
      inputLayer.project(hiddenLayer);
      hiddenLayer.project(hiddenLayer2);
      hiddenLayer2.project(outputLayer);
      function indexOfMax(arr) {
    let maxIndex = 0;
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > arr[maxIndex]) {
            maxIndex = i;
        }
    }
    return maxIndex;
}
      function filter(x,a,b){
	      if(x=="X"){ return a } else if (x=="O"){ return b }else{ return 0 }
      }
      var myNetwork = new Network({
	      input: inputLayer,
	      hidden: [hiddenLayer,hiddenLayer2],
	      output: outputLayer
      });
      function exp(){
        download(myNetwork.toJSON());
      }
      function imp(){
        data = prompt("Paste Network.txt here:");
        myNetwork = Network.fromJSON(data)
      }
      const TicTac = {
    cPlayer: "X", // Tracks current player (X or O)
    state: Array(9).fill(null), // Board state (null for empty cells)
    gameOver: false, // Indicates if the game is over

    // Initialize the game
    init() {
        this.cBoard();
        document
            .getElementById("reset")
            .addEventListener("click", () => this.reset());
    },

    // Create the game board dynamically
    cBoard() {
        const board = document.getElementById("board");
        board.innerHTML = ""; // Clear previous board
        this.state.forEach((_, i) => {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.index = i;
            board.appendChild(cell);
        });
        board.addEventListener("click", (e) => this.handleClick(e)); // Handle clicks on the board
        this.uMessage(`Player ${this.cPlayer}'s turn`);
    },

    // Handle a cell click
    airun(thiscPlayer,thisstate){
	if(localStorage.fuckyourself){
		var condition = true
	    }else{
		var condition = (thiscPlayer == "O")
	    }
	    if(condition){
		  var act = thisstate
	        
	          act = act.map((x) => filter(x,-1,1))
		  console.log(act)
		  var cho = myNetwork.activate(act)
		  var choose = indexOfMax(cho)
		  while(!thisstate[choose]){
		      cho[choose] = -1000000000000000000
		      choose = indexOfMax(cho)
		  }
		  console.log(cho)
		  console.log("choosed:" + choose)
		  
		  document.querySelectorAll('[data-index="' + choose + '"]')[0].click();
	    }
    },
    handleClick(e) {
        const cell = e.target;
        const i = cell.dataset.index;
        // Ignore clicks if game is over or cell is taken
        if (this.gameOver || !cell.classList.contains("cell") || this.state[i])
            return;

        // Update board state and UI
	var act = this.state
	act = act.map((x) => filter(x,-1,1))
        console.log(myNetwork.activate(act));
        var train = Array(9).fill(0)
        this.state[i] = this.cPlayer;
	
        train[i] = 1
	console.log(train)
        myNetwork.propagate(0.3, train);
        cell.textContent = this.cPlayer;
        cell.classList.add("taken");

        // Check for winner or tie
        const winCombo = this.checkWin();
        if (winCombo) {
            this.highlight(winCombo);
            this.uMessage(`Player ${this.cPlayer} wins!`);
            this.gameOver = true;
            setTimeout(this.reset(),1000)
        } else if (this.state.every((cell) => cell)) {
            this.uMessage("It's a tie!");
            this.gameOver = true;
	    setTimeout(this.reset(),1000)
        } else {
            // Switch players
            this.cPlayer = this.cPlayer === "X" ? "O" : "X";
            this.uMessage(`Player ${this.cPlayer}'s turn`);
	    this.airun(this.cPlayer,this.state)
        }
    },

    // Check if there's a winning combination
    checkWin() {
        const wins = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8], // Rows
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8], // Columns
            [0, 4, 8],
            [2, 4, 6], // Diagonals
        ];
        return wins.find((combo) =>
            combo.every((i) => this.state[i] === this.cPlayer)
        );
    },

    // Highlight winning cells
    highlight(combo) {
        combo.forEach((i) => {
            document.getElementById("board").children[i].style.color = "red";
        });
    },

    // Reset the game
    reset() {
        this.state = Array(9).fill(null);
        this.cPlayer = "X";
        this.gameOver = false;
        this.cBoard();
    },

    // Update the game status message
    uMessage(msg) {
        document.getElementById("message").textContent = msg;
    },
};

// Start the game
TicTac.init();
    </script>
</head>


</html>
